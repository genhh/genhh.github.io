<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础数据结构题型总结</title>
      <link href="2022/02/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>2022/02/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基础数据结构题型总结"><a href="#基础数据结构题型总结" class="headerlink" title="基础数据结构题型总结"></a>基础数据结构题型总结</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>力扣题库</p><h3 id="2两数相加"><a href="#2两数相加" class="headerlink" title="2两数相加"></a>2两数相加</h3><p>c++关于链表的初始化使用不熟练，基础不扎实</p><p>逻辑没理清，卡在循环初始化节点与返回头指针的处理上,先初始化头结点后，后面就不好处理初始化新的节点，如果头结点也加入计算的话。(解决方案:直接返回头结点的下一个节点，头结点不加入计算)</p><p>优质思路:<br>把两个链表一长一短的情况通过三目符(?:)来使得null转换为0，使得其过程泛化，避免多条件判断下的代码冗余</p><p>基础:<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ListNode() : val(0), next(nullptr) &#123;&#125; &#x2F;&#x2F;初始化函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>其中:为所做的初始化，即为将0赋值给变量val,将nullptr赋值给变量next</p><p>new的作用:</p><p>1 指针变量的实体化</p><p>声明结构体时为什么不用加struct也不会报错？</p><p>指针变量和实变量的区别:</p><p>指针变量只存储指向地址，无法存储别的值，普通变量直接使用即可。</p><p>调用指针指向的变量成员需要用”-&gt;”,调用其他变量的成员使用”.”</p><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19 删除链表的倒数第 N 个结点"></a>19 删除链表的倒数第 N 个结点</h3><p>个人思路:把给的倒序删除参数n转换成正序参数，然后进行删除。(链表长度+双指针法)</p><p>其他思路：</p><p>1递归实现<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    int cur&#x3D;0;    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;       if(!head) return NULL;       head-&gt;next &#x3D; removeNthFromEnd(head-&gt;next,n);       cur++;       if(n&#x3D;&#x3D;cur) return head-&gt;next;       return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>2快慢指针，快指针先走n步，然后快慢一起走，直到快指针走到最后，要注意的是可能是要删除第一个节点，这个时候可以直接返回head -&gt; next<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        if(!head | !head -&gt; next) return NULL;        ListNode * fast &#x3D; head, *slow &#x3D; head;        for(int i &#x3D; 0; i &lt; n; i++)&#123;            fast &#x3D; fast -&gt; next;        &#125;        if(!fast)&#123;            return head -&gt; next;            &#125;                while(fast -&gt; next)&#123;            fast &#x3D; fast -&gt; next;            slow &#x3D; slow -&gt; next;        &#125;        slow -&gt; next &#x3D; slow -&gt; next -&gt; next;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>3 栈</p><p>在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummy &#x3D; new ListNode(0, head);        stack&lt;ListNode*&gt; stk;        ListNode* cur &#x3D; dummy;        while (cur) &#123;            stk.push(cur);            cur &#x3D; cur-&gt;next;        &#125;        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            stk.pop();        &#125;        ListNode* prev &#x3D; stk.top();        prev-&gt;next &#x3D; prev-&gt;next-&gt;next;        ListNode* ans &#x3D; dummy-&gt;next;        delete dummy;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>小失误:没有加break，导致最后只剩下一个链表非null时while循环无法停下。</p><p>优化:<br>1可以只初始化一个表头，其余的拼接原有链表节点即可，不需要额外申请新节点</p><p>2最后合并时可以使用三目符减少代码量</p><p>其他思路:</p><p>递归实现：<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if (l1 &#x3D;&#x3D; nullptr) &#123;            return l2;        &#125; else if (l2 &#x3D;&#x3D; nullptr) &#123;            return l1;        &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123;            l1-&gt;next &#x3D; mergeTwoLists(l1-&gt;next, l2);            return l1;        &#125; else &#123;            l2-&gt;next &#x3D; mergeTwoLists(l1, l2-&gt;next);            return l2;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a>23. 合并K个升序链表</h3><p>基础缺乏:</p><p>1 <strong>结构体的定义</strong>:可以像类一样定义么？√</p><p>C++中的struct与class比较类似。struct默认访问权限是public，class是private；class有继承，多态机制，而struct没有。</p><p>2 <strong>STL优先队列的用法未掌握</strong>：参数，重载运算符的定义方式，比较函数的定义类型(为什么会重载()?)</p><p>优先队列的参数只有第一个type是必须的，后面的容器类型和比较类型会默认生成，如果要定义容器类型，那么比较类型也要定义</p><p>operator在类内定义时，参数只需要运算符后面的对象，在类外定义时(友元)，参数个数按正常运算所需个数走。</p><p>优先队列如果要自定义排序函数，只能用仿函数，不能用普通函数的指针</p><p>仿函数：使一个类的使用看上去像一个函数</p><p>返回bool类型的仿函数称为谓词</p><p>如果operator()接受一个参数，那么叫做一元谓词</p><p>如果operator()接受两个参数，那么叫做二元谓词</p><p>为什么会重载():好像默认就是这样，类内重载”&lt;”,类外重载”()”<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct tmp1 &#x2F;&#x2F;运算符重载&lt;&#123;    int x;    tmp1(int a) &#123;x &#x3D; a;&#125;    bool operator&lt;(const tmp1&amp; a) const    &#123;        return x &lt; a.x; &#x2F;&#x2F;大顶堆    &#125;&#125;;struct tmp2 &#x2F;&#x2F;重写仿函数&#123;    bool operator() (tmp1 a, tmp1 b)     &#123;        return a.x &lt; b.x; &#x2F;&#x2F;大顶堆    &#125;&#125;;struct Status &#123;        int val;        ListNode *ptr;        bool operator &lt; (const Status &amp;rhs) const &#123;            return val &gt; rhs.val; &#x2F;&#x2F;小顶堆        &#125;    &#125;;struct comp &#123;        bool operator()(ListNode* a, ListNode* b) &#123;            return a-&gt;val &gt; b-&gt;val;&#x2F;&#x2F;小顶堆        &#125;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>3<strong>移位运算符</strong>:”&gt;&gt;1”当时没反应过来</p><p>4 记得声明完头结点后给头结点初始化</p><p>5 优先队列的比较函数定义还是未明白</p><p>6 链表题最重要的一点就是<strong>判断节点是否存在</strong></p><h3 id="24两两交换链表中的节点"><a href="#24两两交换链表中的节点" class="headerlink" title="24两两交换链表中的节点"></a>24两两交换链表中的节点</h3><p>未考虑交换后的末尾已交换的链表保存问题，自己误认为只需要2个指针即可，实际上需要三个，最后一个保存已交换后的链表的地址。</p><p>链表的边界判断还是不够熟练</p><p>其他思路:</p><p>递归</p><p>把整个链表看成三个部分，头结点，第二个节点，以及其他部分，交换完后返回第二个节点。边界条件是单个节点或者为空时返回<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#123;            return head;        &#125;        ListNode* newHead &#x3D; head-&gt;next;        head-&gt;next &#x3D; swapPairs(newHead-&gt;next);        newHead-&gt;next &#x3D; head;        return newHead;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h3><p>弱点:思路没问题（使用栈结构使得数量为k的子链表进行翻转），就是实现过程代码能力不足，老是<strong>数组越界</strong>，原因是因为stack定义类型不对，应该用指针而非节点类型(差了个*)，可能是因为节点存到stack中会破坏原有链表结构而指针不会？</p><p>其他思路:<br>尾插法：可以理解为把末尾的节点与头结点进行交换</p><p>递归：<br>先写出边界条件和递归，最后写出每次递归需要的相应操作并返回。</p><h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><p>思路:将单链表构成循环链表(头尾相连)，向前遍历头结点len-(k%len)-1次断开即可(与官方题解思路一致)</p><p>这题比较简单，一次成。</p><h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86 分隔链表"></a>86 分隔链表</h3><p>思路不够严谨，想要在原有链表上做尽可能少的处理完成题目。</p><p>官方思路:弄两个头节点，一个存比目标大的节点，一个存比目标小的节点，最后再合并。</p><p>老是出现内存问题（heap-use-after-free），没有指向NULL的结点，解决方法:large那一链表末加nullptr。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://xxx.com">引用文章标题1</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论复习总结</title>
      <link href="2021/12/22/%E7%9F%A9%E9%98%B5%E8%AE%BA%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>2021/12/22/%E7%9F%A9%E9%98%B5%E8%AE%BA%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵论复习总结"><a href="#矩阵论复习总结" class="headerlink" title="矩阵论复习总结"></a>矩阵论复习总结</h1><p>关于期末考试常见考点题型的总结，有所错误欢迎指正</p><h1 id="一、矩阵的相似变换"><a href="#一、矩阵的相似变换" class="headerlink" title="一、矩阵的相似变换"></a>一、矩阵的相似变换</h1><h2 id="多项式化简"><a href="#多项式化简" class="headerlink" title="多项式化简"></a>多项式化简</h2><p>特征多项式，最小多项式</p><h3 id="求解最小多项式"><a href="#求解最小多项式" class="headerlink" title="求解最小多项式"></a>求解最小多项式</h3><p>(1)$m<em>A(\lambda) = \frac{\phi (\lambda)}{D</em>{n-1}(\lambda)}$,其中$\phi(\lambda)=det(\lambda I -A),D_{n-1}$为 $\lambda I -A$的<strong>n-1阶行列式因子</strong></p><p>(2)书中定理1.17:设$A\in C^{m\times n}$,$\lambda_1,\lambda_2,\dots,\lambda_t$是A的所有互不相同的特征值,则:</p><script type="math/tex; mode=display">m_A(\lambda) = (\lambda-\lambda_1)^{m_1}(\lambda-\lambda_2)^{m_2}\dots (\lambda-\lambda_t)^{m_t}</script><p>其中$m_i$是$A$的Jordan标准形$J$中含$\lambda_i$的Jordan块的最高阶数</p><h2 id="Schmidt正交化方法"><a href="#Schmidt正交化方法" class="headerlink" title="Schmidt正交化方法"></a><font color="red">Schmidt正交化方法</font></h2><p>(<strong>记忆</strong>)从线性无关向量组导出<strong>正交向量组</strong>的方法</p><script type="math/tex; mode=display">y_1 = x_1, y_j = x_j - \frac{(x_j,y_1)}{(y_1,y_1)}y_1 - \dots - \frac{(x_j,y_{j-1})}{(y_{j-1},y_{j-1})}y_{j-1}\quad (j=2,\dots ,s)</script><p>Schmidt只做了正交化处理，若想获得标准正交基还要在此基础上进行<strong>单位化</strong>(各自除以各自正交基的模值)</p><h2 id="相似对角化-P-1-AP-wedge"><a href="#相似对角化-P-1-AP-wedge" class="headerlink" title="相似对角化$P^{-1}AP=\wedge$"></a>相似对角化$P^{-1}AP=\wedge$</h2><p>能相似对角化的前提是矩阵$A\in C^n$有n个线性无关的特征向量</p><h2 id="Jordan标准形-P-1-AP-J"><a href="#Jordan标准形-P-1-AP-J" class="headerlink" title="Jordan标准形$P^{-1}AP=J$"></a><font color="red">Jordan标准形$P^{-1}AP=J$</font></h2><p>(1)<strong>特征向量法</strong></p><p>Jordan矩阵阶数等价于特征值的个数(包括重数)，Jordan块的个数等价于线性无关的特征向量的数量，每个Jordan块的对角元素是相对应的特征值</p><p><strong>注意</strong>:某一特征值重数较高时可能无法确定Jordan块</p><p>(2)<strong>初等变换法</strong></p><p>首先将<strong>特征矩阵</strong>($\lambda I -A$)化为<strong>Smith标准形</strong>，得到<strong>不变因子</strong>，然后再计算得到<strong>初等因子</strong>。每个初等因子的幂次为Jordan块阶数，元素是对应的特征值，总和为原矩阵的阶数。</p><p>(3)<strong>行列式因子法</strong></p><p>先求出特征矩阵所对应的n个<strong>行列式因子</strong>，然后根据公式算出A的<strong>不变因子</strong>，然后算<strong>初等因子</strong>和Jordan标准形</p><h3 id="求相似变换矩阵P"><a href="#求相似变换矩阵P" class="headerlink" title="求相似变换矩阵P"></a>求相似变换矩阵P</h3><p>page15<br><strong>待完成</strong></p><h2 id="酉相似-U-1-AU-wedge-quad-U-1-AU-T"><a href="#酉相似-U-1-AU-wedge-quad-U-1-AU-T" class="headerlink" title="酉相似$U^{-1}AU=\wedge$, $\quad U^{-1}AU=T$"></a>酉相似$U^{-1}AU=\wedge$, $\quad U^{-1}AU=T$</h2><p>这里$T$表示上三角矩阵</p><h2 id="常用定义和定理"><a href="#常用定义和定理" class="headerlink" title="常用定义和定理"></a>常用定义和定理</h2><p><strong>Smith标准形</strong>:</p><p><strong>不变因子$d_k(\lambda)$</strong>:smith标准形里的元素,$d<em>r(\lambda) = \frac{D_r(\lambda)}{D</em>{r-1}(\lambda)}$</p><p><strong>初等因子</strong>:所有不变因子中的一次因式方幂</p><p><strong>行列式因子$D_k(\lambda)$</strong>:$A(\lambda)$的全部k阶子式的<strong>首一最大公因式</strong>$D_k(\lambda)$（子式的取得方法与余子式一致，不全是连续的行或列构成的子式）</p><p><strong>零化多项式$f(\lambda)$</strong>:$f(\lambda)$为多项式，使$f(A)=0$</p><p><strong>最小多项式</strong>:A的零化多项式中<strong>次数最低</strong>的首一多项式，即包含了所有互不相同的特征值(即每个特征值对应一个Jordan块)</p><p><strong>酉矩阵</strong>:$A^HA = I$,当矩阵内元素全为实数时退化为正交矩阵,即$A^TA=I$</p><h1 id="二、范数理论"><a href="#二、范数理论" class="headerlink" title="二、范数理论"></a>二、范数理论</h1><h2 id="证明构造的向量范数是向量范数"><a href="#证明构造的向量范数是向量范数" class="headerlink" title="证明构造的向量范数是向量范数"></a>证明构造的向量范数是向量范数</h2><h2 id="证明构造的矩阵范数是矩阵范数"><a href="#证明构造的矩阵范数是矩阵范数" class="headerlink" title="证明构造的矩阵范数是矩阵范数"></a>证明构造的矩阵范数是矩阵范数</h2><p>需要证明4个性质均满足:</p><p>非负性:当$A\neq 0$时，$||A||&gt;0$，当$A=0$时，$||A||=0$.</p><p>齐次性:对任意$\lambda\in C$,$||\lambda A|| = |\lambda|\cdot ||A||$</p><p>三角不等式:对任意$A,B\in C^{n\times n}$,都有$||A+B||\le||A||+||B||$</p><p>三角不等式证明：</p><p>相容性:对任意$A,B\in C^{n\times n}$,都有$||AB||\le||A||\quad ||B||$</p><p>相容性证明:首先进行第一次放缩:<strong>和的模小于模的和</strong>；然后进行第二次放缩:<strong>积的和小于和的积</strong>,若外部带次幂，则利用Cauchy-Schwarz不等式或者holder不等式。卡壳时也可根据结果倒推中间部分过程。</p><p>特殊情况下有时还需对原范数形式进行一定变形才会更好证明(如平方或数乘等)</p><h2 id="证明矩阵范数与向量范数相容"><a href="#证明矩阵范数与向量范数相容" class="headerlink" title="证明矩阵范数与向量范数相容"></a>证明矩阵范数与向量范数相容</h2><script type="math/tex; mode=display">||Ax||_v \le ||A||_m ||x||_v</script><p>若上式满足，则说明矩阵范数$||\cdot||_m$与向量范数$||\cdot||_v$是<strong>相容</strong>的</p><p>与证明矩阵范数的相容性类似</p><h2 id="范数证明常用放缩方式"><a href="#范数证明常用放缩方式" class="headerlink" title="范数证明常用放缩方式"></a>范数证明常用放缩方式</h2><p>(1)$|\sum\limits<em>{k=1}^n a</em>{ik}b<em>{kj}|\le \sum\limits</em>{k=1}^n |a<em>{ik}||b</em>{kj}| \le \sum\limits<em>{k=1}^n |a</em>{ik}|\sum\limits<em>{k=1}^n|b</em>{kj}|$</p><p>(2)$(\sum\limits<em>{k=1}^n |a</em>{ik}||b<em>{kj}|)^2 \le (\sum\limits</em>{k=1}^n |a<em>{ik}|^2)(\sum\limits</em>{k=1}^n|b_{kj}|^2)$ (C-S不等式)</p><p>(3)$|x_i+y_i|^2 \le (|x_i|+|y_i|)^2$</p><p>(4)$\sum |x<em>{i}||y</em>{i}| \le (\sum |x<em>{i}|^p)^{\frac{1}{p}}(\sum|y</em>{i}|^q)^{\frac{1}{q}}$,其中${\frac{1}{p}}+{\frac{1}{q}}=1$</p><h2 id="常见范数总结"><a href="#常见范数总结" class="headerlink" title="常见范数总结"></a>常见范数总结</h2><p>其中$x=(x_1,x_2,\dots,x_n)^T$。</p><p>导出范数定义(一般都是将分母取1消掉max符号):</p><script type="math/tex; mode=display">||A|| = \max\limits_{x\neq 0} \frac{||Ax||_v}{||x||_v}</script><script type="math/tex; mode=display">\begin{array}{|c|c|c|}\hline{范数类型} & {名称} & {计算公式}  \\\hline{向量范数} & {1范数} & {||x||_1 = \sum\limits_{k=1}^n |x_k|}  \\\hline{} & {2范数} & {||x||_2 = \sqrt{\sum\limits_{k=1}^n |x_k|^2=\sqrt{x^Hx} } }  \\\hline{} & \infty范数 & {||x||_{\infty} = \max\limits_k|x_k|}  \\\hline{} & {p范数} & {||x||_p = (\sum\limits^n_{k=1}|x_k|^p)^{\frac{1}{p} } }  \\\hline{} & {加权范数(椭圆范数)} & {||x||_A = \sqrt{x^HAx} }  \\\hline{矩阵范数} & {m1范数} & {||A||_{m1}=\sum\limits^m_{i=1}\sum\limits^n_{j=1}|a_{ij}|}  \\\hline{} & {F范数} & {||A||_{F}=\sqrt{\sum\limits^m_{i=1}\sum\limits^n_{j=1}|a_{ij}|^2}=\sqrt{tr(A^HA)} }  \\\hline{} & {m\infty范数} & {||A||_{m_{\infty} }=n \max\limits_{i,j}|a_{ij}|}  \\\hline{} & {M范数} & {||A||_{M} = \max\{m,n\}\max\limits_{i,j}|a_{ij}|}  \\\hline{} & {G范数(几何平均范数)} & {||A||_{G} = \sqrt{mn}\max\limits_{i,j}|a_{ij}|}  \\\hline{导出范数} & {1范数(列和范数)} & {||A||_{1} = \max\limits_j\sum\limits^m_{i=1}|a_{ij}|}  \\\hline{} & {2范数(谱范数)} & {||A||_{2} = \sqrt{A^HA的最大特征值} }  \\\hline{} & {\infty范数(行和范数)} & {||A||_{\infty} = \max\limits_i\sum\limits^n_{j=1}|a_{ij}|}  \\\hline\end{array}</script><p>注意:复数的模($z = a+bi$): $|z| = \sqrt{a^2+b^2}$</p><h1 id="三、矩阵分析"><a href="#三、矩阵分析" class="headerlink" title="三、矩阵分析"></a>三、矩阵分析</h1><h2 id="矩阵函数值计算"><a href="#矩阵函数值计算" class="headerlink" title="矩阵函数值计算"></a><font color="red">矩阵函数值计算</font></h2><p>(1)<strong>利用Hamilton-Cayley定理化简求解</strong></p><p>Hamilton定理:$\phi(\lambda) = det(\lambda I -A)=p[\lambda]^n=0 \rightarrow \phi(A)=0$</p><p>(2)<strong>对角矩阵法</strong></p><p>若$A$可对角化，则可以推出$f(A)=\sum\limits^{+\infty}_{k=0}a_kA^k=Pdiag(f(\lambda_1),f(\lambda_2),\dots,f(\lambda_n) )P^{-1}$</p><p>同理可得$f(At)=Pdiag(f(\lambda_1t),f(\lambda_2t),\dots,f(\lambda_nt) )P^{-1}$</p><p>(3)<strong>Jordan标准形</strong></p><script type="math/tex; mode=display">f(At)=P{ \begin{bmatrix}f(J_1t)& & \\& \ddots& \\& & f(J_s)t\\    \end{bmatrix} }P^{-1}</script><p>其中$J_i$为Jordan块</p><p>(4)<strong>待定系数法</strong></p><p>也是根据Hamilton定理进行处理:</p><script type="math/tex; mode=display">f(At) = q(A,t)\phi(A)+r(A,t)=r(A,t)=b_{n-1}A^{n-1}+\dots + b_1(t)A+b_0(t)I</script><p>其中$\phi(A)=0$,所以可以推出$\phi^{(l)}(\lambda<em>i)=0 \quad(l=0,1,\dots,r</em>{i-1};i=1,2,\dots,s)$</p><p>所以可以得到下面的一组方程解:</p><script type="math/tex; mode=display">\frac{d^l}{d\lambda^l}r(\lambda,t)|_{\lambda=\lambda_i} = \frac{d^l}{d\lambda^l}f(\lambda t)|_{\lambda=\lambda_i} \quad(l=0,1,\dots,r_{i-1};i=1,2,\dots,s)</script><p>解出$b_k$后即可算出$f(At)$,$r$表示某特征值的重数,$s$表示互不相同的特征值的个数，等式右侧若是$l$阶导数，则记得乘$t^l$。</p><h2 id="数量函数对矩阵变量的导数"><a href="#数量函数对矩阵变量的导数" class="headerlink" title="数量函数对矩阵变量的导数"></a>数量函数对矩阵变量的导数</h2><p><strong>待完成</strong></p><h2 id="求微分方程的解"><a href="#求微分方程的解" class="headerlink" title="求微分方程的解"></a>求微分方程的解</h2><h3 id="求解非齐次微分方程组-frac-d-dt-x-t-Ax-t-b-t"><a href="#求解非齐次微分方程组-frac-d-dt-x-t-Ax-t-b-t" class="headerlink" title="求解非齐次微分方程组$\frac{d}{dt}x(t) = Ax(t)+b(t)$"></a>求解非齐次微分方程组$\frac{d}{dt}x(t) = Ax(t)+b(t)$</h3><p>(1)计算矩阵指数函数$e^{At}$</p><p>(2)计算积分$y(t) = \int^t_{t_0}e^{-A\tau}b(\tau)d\tau\quad$(把$e^{At}$中的$t$替换为$-\tau$即可，$b(\tau)$中的$e^\tau$为<strong>标量</strong>)</p><p>(3)计算满足初始条件$x(t_0)=x_0$的解$x(t)=e^{At}x_0+e^{At}y(t)$</p><h2 id="常见矩阵函数总结"><a href="#常见矩阵函数总结" class="headerlink" title="常见矩阵函数总结"></a>常见矩阵函数总结</h2><script type="math/tex; mode=display">e^A = \sum\limits_{k=0}^{+\infty}\frac{1}{k!}A^k</script><script type="math/tex; mode=display">sinA = \sum\limits_{k=0}^{+\infty}\frac{(-1)^k}{(2k+1)!}A^{2k+1}</script><script type="math/tex; mode=display">cosA = \sum\limits_{k=0}^{+\infty}\frac{(-1)^k}{(2k)!}A^{2k}</script><script type="math/tex; mode=display">\frac{1}{1+x} = \sum\limits_{k=0}^{+\infty}(-1)^kA^{k}</script><script type="math/tex; mode=display">\frac{1}{1-x} = \sum\limits_{k=0}^{+\infty}A^{k}</script><h2 id="幂级数收敛条件"><a href="#幂级数收敛条件" class="headerlink" title="幂级数收敛条件"></a>幂级数收敛条件</h2><p>矩阵函数$\sum\limits<em>{k=0}^{+\infty}a_kA^k$的<strong>谱半径小于</strong>其对应的幂级数$\sum\limits</em>{k=0}^{+\infty}a<em>kz^k$的收敛半径$R = \lim\limits</em>{n\rightarrow\infty}|\frac{a<em>{n}}{a</em>{n+1}}|$(<strong>相邻级数系数之比</strong>)<br>,则表示矩阵函数收敛。</p><p>若等于时，则需要判断矩阵内各元素是否收敛，全收敛则收敛。</p><h1 id="四、矩阵分解"><a href="#四、矩阵分解" class="headerlink" title="四、矩阵分解"></a>四、矩阵分解</h1><h2 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a><font color="red">QR分解</font></h2><p>Q是酉矩阵,R是具有正对角元的上三角矩阵，<strong>分解结果是唯一的</strong></p><p>(1)<strong>Schmidt正交化方法</strong></p><p>(矩阵A要可逆)首先将A的列向量进行schmidt正交化，</p><p>然后再单位化后的结果就是Q,</p><p>最后R的每一列根据Schmidt公式和单位化公式反向表示出原列向量$a_j$的方程组的各元素系数得出。</p><script type="math/tex; mode=display">A = (a_1,a_2,\dots ,a_n)=(q_1,q_2,\dots ,q_n){\begin{bmatrix} \mathbf ||p_1||_2 & \mathbf \lambda_{21}||p_1||_2 & \mathbf \ldots &\lambda_{n1}||p_1||_2 \\ & ||p_2||_2 & \ldots &\lambda_{n2}||p_2||_2 \\  & & \ddots &\vdots \\   &  & &||p_n||_2 \end{bmatrix} }=QR</script><p>其中$q<em>k=\frac{p_k}{||p_k||_2}$,$p_k$则是根据Schmidt正交化得来，$\lambda</em>{ij}=\frac{(a_i,p_j)}{(p_j,p_j)}$</p><p>(2)<strong>Givens变换</strong></p><p>与HouseHolder变换的主要区别是每列变换时不是一个H矩阵，而是一系列的givens矩阵。</p><p>givens变换从几何上理解可以理解为旋转变换，因此<strong>模长不会改变</strong>,</p><p>性质:givens矩阵T是<strong>酉矩阵</strong>，且<strong>行列式值为1</strong>。</p><p>第1列:</p><p>根据矩阵$A$选取c,s生成givens矩阵$T<em>{12}$,计算$T</em>{12}A$,观察第一列列向量是否只有第一维非0，若不是，则从$T<em>{12}A$选取新的c,s从而生成新的givens矩阵$T</em>{13}$，计算$T<em>{13}T</em>{12}A$的结果。重复上述操作直至第一列列向量满足第一维元素非0，其他维为0.如果原矩阵或累乘矩阵第$j$行第1列位置元素本身为0，则跳过计算$T_{1j}$,计算后续非零位置对应的givens矩阵。</p><p>第2列:</p><p>后续每列和第一列操作类似</p><p>最后得$R = T<em>{n-1,n}\dots T</em>{2n}\dots T<em>{23}T</em>{1n}\dots T_{12}A$,</p><p>$Q=T<em>{12}^H\dots T</em>{1n}^HT<em>{23}^H\dots T</em>{2n}^H\dots T_{n-1,n}^H$</p><p><strong>givens矩阵T的生成规则</strong>，T一般是方阵，givens矩阵是在单位矩阵$I$的基础上，根据矩阵$T<em>{ij}$的下标替换对应$t</em>{ii},t<em>{ij},t</em>{ji},t_{jj}$的元素。($i&lt;j$)然后替换元素满足下式:</p><script type="math/tex; mode=display">t_{ii} = \bar{c}, t_{ij}=\bar{s},t_{ji}=-s,t_{jj}=c</script><p>c和s的求法:<br>与givens矩阵$T<em>{ij}$下标和累乘矩阵($A,T</em>{12}A,\dots$)有关，即$c=\frac{a<em>{ii} }{\sqrt{a</em>{ii}^2+a<em>{ij}^2} }$,$s=\frac{a</em>{ij} }{\sqrt{a<em>{ii}^2+a</em>{ij}^2} }$</p><p>(3)<strong>Householder变换</strong></p><p>Householder变换从几何上可以理解为镜面反射变换，因此<strong>模长也不变</strong></p><p>$A = (a_1,a_2,\dots,a_n)$($n\ge 3$)</p><p>第1列:</p><p>取$a<em>1=(a</em>{11},a<em>{21},\dots,a</em>{n1})$,计算$u_1=\frac{a_1-\alpha_1 e_1}{||a_1-\alpha_1 e_1||_2}$,其中$\alpha_1 = ||a_1||_2$，$e_1$为单位向量(第一项为1，其余为0，维数为n维)</p><p>计算$H_1 = I-2u_1u_1^T, B=H_1A$</p><p>第2列:</p><p>取$b<em>2 =(b</em>{22},\dots,b_{n2})$(n-1维),计算$\tilde{u_2}=\frac{b_2-\alpha_2 \tilde{e_1} }{||b_2-\alpha_2 \tilde{e_1}||_2}$,其中$\alpha_2=||b_2||_2$,$\tilde{e_1}$为单位向量(维数为n-1维)</p><p>计算$\tilde{H_2} = I-2u_2u_2^T$(n-1维),$H_2={\begin{bmatrix}<br>1&amp; 0^T\<br>0 &amp; \tilde{H_1}\<br>\end{bmatrix} }$,$C = H_2H_1A$</p><p>第n-1列:</p><p>取$x<em>{n-1} =(x</em>{n-1,n-1},\dots,b<em>{n,n-1})$(2维),计算$\tilde{u</em>{n-1} }=\frac{x<em>{n-1}-\alpha</em>{n-1} \tilde{e<em>1} }{||x</em>{n-1}-\alpha<em>{n-1} \tilde{e_1}||_2}$,其中$\alpha</em>{n-1}=||x_{n-1}||_2$,$\tilde{e_1}$为单位向量(维数为2维)</p><p>计算$\tilde{H<em>{n-1} } = I-2u_2u_2^T$(2维),$H</em>{n-1}={\begin{bmatrix}<br>1&amp; &amp; 0^T\<br>&amp; \ddots&amp; \<br>0&amp; &amp; \tilde{H<em>{n-1} }\<br>\end{bmatrix} }</em>{n\times n}$ , $R = H<em>{n-1}\dots H_2H_1A$ ,$\quad Q = H</em>{1}H<em>2\dots H</em>{n-1}$</p><p><strong>注意</strong>:在此过程中只要$H_{t}\dots H_2H_1A$为上三角矩阵即可停止</p><h2 id="满秩分解"><a href="#满秩分解" class="headerlink" title="满秩分解"></a><font color="red">满秩分解</font></h2><p><strong>满秩分解不唯一</strong></p><p>(1)<strong>逆矩阵方法</strong></p><p>算出Hermite标准形变换过程中的矩阵S,T</p><p>首先进行行变换使得$(A,I_m)\rightarrow(H,S)$</p><p>然后进行列变换使得${\begin{bmatrix}<br>H \<br> I_n\<br>\end{bmatrix} }\rightarrow {\begin{bmatrix}<br>{\begin{bmatrix}<br>I_r&amp;0 \<br>0&amp;0\<br>\end{bmatrix} } \<br> T\<br>\end{bmatrix} }$</p><p>最后可以得到$F=s^{-1}{\begin{bmatrix}<br>I_r \<br> 0\<br>\end{bmatrix} }$, $G=(I_r \quad 0)T^{-1}$</p><p>(2)<strong>Hermite标准形方法</strong></p><p>A的Hermite标准形H:矩阵A经过行变换后的阶梯矩阵(每一行首非0元素为1且对应列只有该元素非0)</p><p>取A的$j_1,j_2,\dots,j_r$列构成矩阵F(列满秩),取H的前r行构成矩阵G(行满秩)，则$A=FG$即为A的一个满秩分解。</p><p><strong>快速求解二阶矩阵的逆</strong>:行列式不为0的情况下，主对角线元素互换，副对角线元素变号，外面再乘<strong>行列式分之一</strong>，这在算由满秩分解的FG来求得的$A^+$时如果求逆为2阶，会更快</p><h1 id="五、特征值的估计与表示"><a href="#五、特征值的估计与表示" class="headerlink" title="五、特征值的估计与表示"></a>五、特征值的估计与表示</h1><h2 id="盖尔圆-Gerschgorin-分离矩阵特征值"><a href="#盖尔圆-Gerschgorin-分离矩阵特征值" class="headerlink" title="盖尔圆(Gerschgorin)分离矩阵特征值"></a><font color="red">盖尔圆(Gerschgorin)分离矩阵特征值</font></h2><p>先算出矩阵$A$的盖尔圆，然后选取<strong>对角矩阵</strong>$D$,计算矩阵$B=DAD^{-1}$的盖尔圆，使得相交的盖尔圆分离(矩阵D第i个元素大于1,则放大第i个盖尔圆，反之小于1则缩小第i个盖尔圆)</p><p>盖尔圆: </p><script type="math/tex; mode=display">G_i = \{z |\quad |z-a_{ii}|\le R_i, z\in C\}</script><p>其中$R<em>i = \sum\limits^{n}</em>{j=1,j\neq i}|a_{ij}|, (i=1,2,\dots,n)$,<strong>注意</strong>半径R是模值</p><h2 id="Rayleigh商"><a href="#Rayleigh商" class="headerlink" title="Rayleigh商"></a>Rayleigh商</h2><script type="math/tex; mode=display">R(x)=\frac{x^HAx}{x^Hx}</script><p>其中$A$为Hermite矩阵，$0\neq x\in C^n$<br>矩阵$A$的特征值与Rayleigh商的关系:</p><script type="math/tex; mode=display">\lambda_{min} = \min\limits_{x\neq 0}R(x) \quad \lambda_{max} = \max\limits_{x\neq 0}R(x)</script><h1 id="六、广义逆矩阵"><a href="#六、广义逆矩阵" class="headerlink" title="六、广义逆矩阵"></a>六、广义逆矩阵</h1><h2 id="A-1-的计算"><a href="#A-1-的计算" class="headerlink" title="$A^{ {1} }$的计算"></a>$A^{ {1} }$的计算</h2><p>根据满秩分解<strong>逆矩阵法</strong>得来:</p><script type="math/tex; mode=display">SAP = {\begin{bmatrix}I_r& K\\0& 0\\    \end{bmatrix} }</script><p>P为置换矩阵。</p><script type="math/tex; mode=display">A^{ \{1\} }=X = P{\begin{bmatrix}I_r& 0\\0& L\\    \end{bmatrix} }S</script><p>当$L\neq0$时，$X = A^{ {1} }$,当$L=0$时,$X = A^{ {1,2} }$</p><h2 id="A-1-的性质"><a href="#A-1-的性质" class="headerlink" title="$A^{ {1} }$的性质"></a>$A^{ {1} }$的性质</h2><p>在这里$A^{(1)}$表示为$A^{ {1} }$的一个实例</p><p>(6)$AA^{(1)} = I_m \leftrightarrow rankA=m$</p><p>(7)$A^{(1)}A = I_n \leftrightarrow rankA=n$</p><h2 id="Moore-Penrose逆-A-的计算"><a href="#Moore-Penrose逆-A-的计算" class="headerlink" title="Moore-Penrose逆$A^+$的计算"></a>Moore-Penrose逆$A^+$的计算</h2><p>由满秩分解$A = FG$而来:</p><script type="math/tex; mode=display">A^+ = G^H(GG^H)^{-1}(F^HF)^{-1}F^H</script><p>F列满秩，G行满秩</p><p>常用结论和性质:</p><p>当$rankA=m$时:$A^+ = A^H(AA^H)^{-1}$</p><p>当$rankA=n$时:$A^+ = (AA^H)^{-1}A^H$</p><p>当矩阵A为酉矩阵时:$A^+ = A^H(AA^H)^{-1}=A^HI=A^H$</p><script type="math/tex; mode=display">(A^HA)^+=A^+(A^H)^+</script><h2 id="A-的应用"><a href="#A-的应用" class="headerlink" title="$A^+$的应用"></a>$A^+$的应用</h2><p>常用来求解形如$AX=b$的线性方程组</p><script type="math/tex; mode=display">AA^+b=b \leftrightarrow 有解</script><p>解的公式是一致的，但是根据有解无解会有不同的名称:</p><p>若<strong>有</strong>解:</p><p><strong>通解:</strong></p><script type="math/tex; mode=display">x = A^+b + (I-A^+A)y</script><p><strong>极小范数解:</strong></p><script type="math/tex; mode=display">x_0 = A^+b</script><p>若<strong>无</strong>解:</p><p><strong>全部最小二乘解:</strong></p><script type="math/tex; mode=display">x = A^+b + (I-A^+A)y</script><p><strong>极小范数最小二乘解:</strong></p><script type="math/tex; mode=display">x _0= A^+b</script><h1 id="七、矩阵的特殊乘积"><a href="#七、矩阵的特殊乘积" class="headerlink" title="七、矩阵的特殊乘积"></a>七、矩阵的特殊乘积</h1><h2 id="直积"><a href="#直积" class="headerlink" title="直积"></a>直积</h2><script type="math/tex; mode=display">A\otimes B ={\begin{bmatrix}a_{11}B & a_{12}B & \dots & a_{1n}B \\a_{21}B & a_{22}B & \dots & a_{2n}B \\\vdots & \vdots &  & \vdots \\a_{m1}B & a_{m2}B & \dots & a_{mn}B \\    \end{bmatrix} }</script><h2 id="直积性质"><a href="#直积性质" class="headerlink" title="直积性质"></a>直积性质</h2><p>(1)$(A\otimes B)^T = A^T\otimes B^T,(A\otimes B)^H = A^H\otimes B^H,$</p><p>(2)$(A\otimes B)(C\otimes D) = (AC)\otimes (BD)$</p><p>(3)$(A\otimes B)^{-1} = A^{-1}\otimes B^{-1}$</p><h2 id="直积的应用"><a href="#直积的应用" class="headerlink" title="直积的应用"></a>直积的应用</h2><p>可以把方程拉直，可以方便的得出有解成立的条件(用到的性质):</p><script type="math/tex; mode=display">\overrightarrow{AXB} = (A\otimes B^T)\vec{X}</script><h1 id="八、线性空间与线性变换"><a href="#八、线性空间与线性变换" class="headerlink" title="八、线性空间与线性变换"></a>八、线性空间与线性变换</h1><h2 id="1-根据子空间-W-1-W-2-，求-W-1-cup-W-2-和-W-1-cap-W-2-的基和维数"><a href="#1-根据子空间-W-1-W-2-，求-W-1-cup-W-2-和-W-1-cap-W-2-的基和维数" class="headerlink" title="1 根据子空间$W_1,W_2$，求$W_1\cup W_2$和$W_1\cap W_2$的基和维数 "></a><font color="red">1 根据子空间$W_1,W_2$，求$W_1\cup W_2$和$W_1\cap W_2$的基和维数 </font></h2><p>假定$W_1 = span{ \alpha_1,\alpha_2}$, $W_2 = span{ \beta_1,\beta_2}$。</p><p>那么$W_1\cup W_2=span{ \alpha_1,\alpha_2,\beta_1,\beta_2}$,要求出$W_1\cup W_2$，将$span{ \alpha_1,\alpha_2,\beta_1,\beta_2}$中的每个元素按列向量的形式写成矩阵形式，<strong>再进行多次行变换得到阶梯矩阵</strong>，每行首一元素所对应的列向量就是$W_1\cup W_2$所需要的基，也是极大线性无关组，个数也就是维数。</p><p>$W_1\cap W_2$则是利用两子空间交集的线性表出相等(即交集的基)得到方程组，然后求解此方程组得到线性表出的系数，然后再根据线性表出写出交集的基和维数。(线性表出也可理解为线性组合)</p><h2 id="2-求线性变换T的值域-R-T-与核-N-T-的基与维数"><a href="#2-求线性变换T的值域-R-T-与核-N-T-的基与维数" class="headerlink" title="2 求线性变换T的值域(R(T) )与核(N(T) )的基与维数"></a><font color="red">2 求线性变换T的值域(R(T) )与核(N(T) )的基与维数</font></h2><p>值域:</p><p>$R(T) =span {T( \alpha _1),T( \alpha _2),\dots ,T( \alpha _n)}$</p><p>根据上式计算原线性空间基经过线性变换后的最大无关组即为值域的基，维数等于秩</p><p>核：</p><p>设$x\in N(T)$，根据$T(x)=0$计算出x的通解，x的基础解系即为核的基，维数等于基础解系的个数</p><h2 id="3-求过渡矩阵"><a href="#3-求过渡矩阵" class="headerlink" title="3 求过渡矩阵"></a><font color="red">3 求过渡矩阵</font></h2><p>在基$\alpha_1,\alpha_2,\dots,\alpha_n$到基$\beta_1,\beta_2,\dots,\beta_n$的过渡矩阵$C$，满足下列关系式(<strong>顺序不要搞混</strong>):</p><script type="math/tex; mode=display">\beta = \alpha C</script><p>所以求过渡矩阵有两种方法:</p><p>(1) 直接法 :直接求$\beta$在基$\alpha$下的坐标，该坐标集合即为过渡矩阵</p><p>(2)间接法:以简单基为媒介进行求解(其中E为简单基，每一列向量只有一项为一且位置不同)</p><script type="math/tex; mode=display">\alpha = EC_1</script><script type="math/tex; mode=display">\beta = EC_2</script><script type="math/tex; mode=display">C = C_1^{-1}C_2</script><h2 id="4-求线性变换T在某一基下的矩阵A"><a href="#4-求线性变换T在某一基下的矩阵A" class="headerlink" title="4 求线性变换T在某一基下的矩阵A"></a><font color="red">4 求线性变换T在某一基下的矩阵A</font></h2><p>在不同基下所对应T的矩阵主要依据下式进行变换求解:</p><script type="math/tex; mode=display">T(\alpha_1,\alpha_2,\dots,\alpha_n) = (\alpha_1,\alpha_2,\dots,\alpha_n)A</script><p>比如说从基$(\alpha_1,\alpha_2,\dots,\alpha_n)$到$(\beta_1,\beta_2,\dots,\beta_n)$所对应的矩阵变换关系如下式所示:</p><script type="math/tex; mode=display">T(\alpha_1,\alpha_2,\dots,\alpha_n) = (\alpha_1,\alpha_2,\dots,\alpha_n)A</script><script type="math/tex; mode=display">T(\beta_1,\beta_2,\dots,\beta_n) = (\beta_1,\beta_2,\dots,\beta_n)B</script><script type="math/tex; mode=display">(\beta_1,\beta_2,\dots,\beta_n) = (\alpha_1,\alpha_2,\dots,\alpha_n)P</script><p>经过推导可得:</p><script type="math/tex; mode=display">T(\beta_1,\beta_2,\dots,\beta_n)=T[(\alpha_1,\alpha_2,\dots,\alpha_n)P] = T[(\alpha_1,\alpha_2,\dots,\alpha_n)]P = (\alpha_1,\alpha_2,\dots,\alpha_n)AP = (\beta_1,\beta_2,\dots,\beta_n)P^{-1}AP</script><p>所以可得$B=P^{-1}AP$，重要是推导过程中的思想，理解了思路，题型稍微变化也能自己推出来</p><h2 id="5-证明不变子空间"><a href="#5-证明不变子空间" class="headerlink" title="5 证明不变子空间"></a><font color="red">5 证明不变子空间</font></h2><p>T是V的一个线性变换,W是V的一个子空间，任意$\alpha$ 都满足 $\alpha \in W \rightarrow T(\alpha) \in W$，则W是V的不变子空间</p><p>若$T$的变换已知，则X未知也可以直接计算$T(X)$来判断W是否为不变子空间</p><h2 id="证明线性变换T是否为可逆变换"><a href="#证明线性变换T是否为可逆变换" class="headerlink" title="证明线性变换T是否为可逆变换"></a>证明线性变换T是否为可逆变换</h2><p>(1)<strong>法一</strong>:判断T是否为双射(单射和满射均满足，一一对应),是双射则说明T为可逆变换</p><p>单射成立判断条件:$T(x)=T(y)\rightarrow x=y$</p><p>双射判断条件:?暂时不清楚</p><p>(2)<strong>法二</strong>:判断T在某一组基下的矩阵是否可逆，A不可逆则说明T不可逆</p><h2 id="6-求线性子空间的基使线性变换的矩阵为对角矩阵"><a href="#6-求线性子空间的基使线性变换的矩阵为对角矩阵" class="headerlink" title="6 求线性子空间的基使线性变换的矩阵为对角矩阵"></a><strong>6 求线性子空间的基使线性变换的矩阵为对角矩阵</strong></h2><p>(1)先确定线性子空间$W$上的简单基$E$</p><p>(2)写出线性变换$T$在基$E$下的矩阵$A$(算出每个简单基所对应的线性变换，然后用简单基进行表示，然后提出的系数即为A的列向量)</p><p>(3)求出$A$的特征值和特征向量，进一步写出相似变换矩阵$P$($P$由特征向量组成)</p><p>(4)算出对应矩阵$P^{-1}AP$的基$\beta$($\beta =EP$)($\beta_i = (e_1,e_2,\dots,e_n)p_i$),即最终结果。</p><p><strong>注意</strong>:要求基为<strong>标准正交基</strong>时，对特征向量进行正交化，正交化后得到的正交变换矩阵$Q$,类似的，按照上述第四步，$Q^{-1}AQ$的基$\beta = EQ$即为最终结果。</p><h2 id="7-求欧氏空间的度量矩阵"><a href="#7-求欧氏空间的度量矩阵" class="headerlink" title="7 求欧氏空间的度量矩阵"></a><strong>7 求欧氏空间的度量矩阵</strong></h2><p>度量矩阵的定义:</p><script type="math/tex; mode=display">A = (a_{i,j})_{m\times n}, \quad a_{i,j}=(\alpha_i,\alpha_j)</script><p>式中$\alpha_i,\alpha_j$为线性空间$V$的第$i,j$个基,度量矩阵是可逆的</p><p><strong>注意内积的具体计算方式根据题目的定义来判断</strong></p><h2 id="8-投影变换"><a href="#8-投影变换" class="headerlink" title="8 投影变换"></a>8 投影变换</h2><p>定义:设L与M为$C^n$的子空间,且$C^n=L+M$,即$C^n$是L与M的<strong>直和</strong>(唯一分解形式)。任意$x\in C^n$可唯一分解为$x=y+z$，其中$y\in L$,$z\in M$。称y为x<strong>沿M到L的投影</strong>，将x变为沿着M到L的投影y的变换称为沿M到L的投影变换，记为$P_{L,M}$,即:</p><script type="math/tex; mode=display">P_{L,M}(x)=y</script><p>投影变换在简单基下的<strong>矩阵</strong>称为投影矩阵，记为$\mathbf{P_{L,M} }$</p><p><strong>投影矩阵计算方法</strong>:$P_{L,M} = (X,\mathbf{0})(X,Y)^{-1}$,其中$X,Y$分别为子空间$L,M$的基</p><h3 id="正交投影变换"><a href="#正交投影变换" class="headerlink" title="正交投影变换"></a>正交投影变换</h3><p>设L是$C^n$的子空间，则称沿着$L^{\perp}$(正交补空间)到$L$的投影变换$P_{L,L^{\perp} }$为正交投影变换，简记为$P_L$</p><p><strong>投影矩阵计算方法</strong>:根据正交补空间的性质可以得到$X^HY=0$,所以：</p><script type="math/tex; mode=display">P_{L,M} = (X,\mathbf{0})(X,Y)^{-1}=(X,\mathbf{0})[(X,Y)^H(X,Y)]^{-1}(X,Y)^H \\= (X,\mathbf{0}){\begin{bmatrix}X^HX& 0\\0& Y^HY\\    \end{bmatrix} }^{-1}{\begin{bmatrix}X^H\\Y^H\\    \end{bmatrix} } = X(X^HX)^{-1}X^H = XX^+</script><h3 id="Moore-Penrose逆的等价定义"><a href="#Moore-Penrose逆的等价定义" class="headerlink" title="Moore-Penrose逆的等价定义"></a><font color="red">Moore-Penrose逆的等价定义</font></h3><p>等价定义:设$A\in C^{m\times n}$,若存在$X\in C^{n\times m}$使得:</p><script type="math/tex; mode=display">AX = P_{R(A)} \quad XA = P_{R(X)}</script><p>则称$X$为$A$的Morre-Penrose逆(即$A^+$),即$AA^+$为投影矩阵</p><h2 id="线性子空间有关证明的性质"><a href="#线性子空间有关证明的性质" class="headerlink" title="线性子空间有关证明的性质"></a>线性子空间有关证明的性质</h2><p>(1)若$V_1,V_2$是线性空间$V^n$的子空间，则$V_1\cap V_2$和$V_1+V_2$也是$V$的子空间，所以维数均小于等于n($V_1+V_2$可以近似理解为$V_1\cup V_2$)</p><p>(2)$dim(V_1+V_2)=dimV_1 + dimV_2-dim(V_1\cap V_2)<script type="math/tex">\rightarrow</script>dim(V_1\cap V_2)=dimV_1 + dimV_2-dim(V_1+ V_2)$</p><p>(3)(线性变换)$dimR(T) = rankA\quad dimN(T) = n-rankA$</p><script type="math/tex; mode=display">dimR(T)+dimN(T)=n</script><p>(4)下面四种说法等价:</p><p>1)$V_1+V_2$是直和 (可以理解为两个子空间没有交集，所以两个子空间的基互相也是线性无关的)</p><p>2)$V_1+V_2$中零元素的分解式唯一</p><p>3)$V_1\cap V_2={0}$</p><p>4)$dim(V_1+V_2)=dimV_1+dimV_2$</p><p><strong>核心定义和定理</strong></p><p>线性变换的定义:同时满足下面两式的变换:</p><script type="math/tex; mode=display">T(\alpha +\beta) = T(\alpha) + T(\beta)</script><script type="math/tex; mode=display">T(k\alpha) = kT(\alpha)</script><h2 id="证明题常见题型"><a href="#证明题常见题型" class="headerlink" title="证明题常见题型"></a>证明题常见题型</h2><h3 id="直和"><a href="#直和" class="headerlink" title="直和"></a><strong>直和</strong></h3><p>分为两步，</p><p>第一步，先证$W_1\cap W_2={0}$,首先假设一个变量$x\in W_1\cap W_2$,然后利用各子空间的性质得到在各子空间下的关于$x$的约束条件，然后在结合题目给的相关条件，证明$x=0$,然后就可以得到$W_1\cap W_2={0}$,即$W_1+W_2$为直和。</p><p>第二步，证明$W_1+ W_2=V^n$,</p><p>证明方法1:如果有给定或者能求出子空间的维数或者关于维数的约束时，可以利用公式$dim(V_1\cap V_2)=dimV_1 + dimV_2-dim(V_1+ V_2)$求出$dim(W_1+W_2)=n$</p><p>证明方法2:构造一个变量$x\in V^n$,其中$x=y+z$,$y\in W_1,z\in W_2$,说明上述情况后可以得到$V^n\subset W_1+W_2$,然后由子空间的性质可知$W_1+W_2\subset V^n$。所以可得$V^n = W_1+W_2$。再由上面已经证明$W_1+W_2$为直和，所以$V^n = W_1\oplus W_2$。</p><h3 id="不变子空间"><a href="#不变子空间" class="headerlink" title="不变子空间"></a>不变子空间</h3><p>前面有<br><a href="#font-colorred5-证明不变子空间font">xxx</a></p><h3 id="对称变换-正交变换"><a href="#对称变换-正交变换" class="headerlink" title="对称变换/正交变换"></a>对称变换/正交变换</h3><h4 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h4><script type="math/tex; mode=display">(T(\alpha),\beta) = (\alpha,T(\beta))</script><h4 id="正交变换"><a href="#正交变换" class="headerlink" title="正交变换"></a>正交变换</h4><script type="math/tex; mode=display">(T(\alpha),T(\beta)) = (\alpha,\beta)</script><p>T在任一<strong>标准正交基</strong>下的矩阵为<strong>正交矩阵</strong></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他类型的证明题常用到的性质一般用到的就是关于<strong>维数</strong>、<strong>特殊矩阵</strong>的性质。</p><h1 id="各类矩阵的性质"><a href="#各类矩阵的性质" class="headerlink" title="各类矩阵的性质"></a>各类矩阵的性质</h1><p><strong>待完成</strong></p><h2 id="1-正定矩阵"><a href="#1-正定矩阵" class="headerlink" title="1 正定矩阵"></a>1 正定矩阵</h2><h2 id="2-投影矩阵"><a href="#2-投影矩阵" class="headerlink" title="2 投影矩阵"></a>2 投影矩阵</h2><p>是幂等矩阵</p><h2 id="3-正交投影矩阵"><a href="#3-正交投影矩阵" class="headerlink" title="3 正交投影矩阵"></a>3 正交投影矩阵</h2><p>(1)$A^2=A$（投影）</p><p>(2)$A^H=A$（正交）</p><p>(3)$\rho(A)=1$,谱半径为1</p><p>(4)$A^+=A$</p><h2 id="4-HouseHolder矩阵"><a href="#4-HouseHolder矩阵" class="headerlink" title="4 HouseHolder矩阵"></a>4 HouseHolder矩阵</h2><p>(1) $H^H=H$</p><p>(2)$H^HH=I$</p><p>(3)$H^2=I$(对合矩阵)</p><p>(4)$H^{-1}=H$(自逆矩阵)</p><p>(5)${ \begin{bmatrix}<br>I_r&amp; 0\<br>0 &amp; H\<br>\end{bmatrix} }$是n+r阶Householder矩阵</p><p>(6)$detH=-1$</p><h2 id="5-givens矩阵"><a href="#5-givens矩阵" class="headerlink" title="5 givens矩阵"></a>5 givens矩阵</h2><p>(1)givens矩阵是酉矩阵</p><p>(2)$detT=1$</p><h2 id="6-酉矩阵"><a href="#6-酉矩阵" class="headerlink" title="6 酉矩阵"></a>6 酉矩阵</h2><script type="math/tex; mode=display">A^HA=I \quad or\quad A^{-1}=A^H</script><p>(1)若$A$是酉矩阵，则$A^{-1}$也是酉矩阵</p><p>(2)若$AB$是酉矩阵，则$AB$也是酉矩阵</p><p>(2)若$A$是酉矩阵，则$|detA|=1$</p><p>(4)$A\rightleftarrows A$的$n$个列向量是<strong>两两正交的单位向量</strong>，当$A$是实数构成的方阵时，酉矩阵就是正交矩阵($AA^T=I$)</p><h2 id="7-Hermite矩阵"><a href="#7-Hermite矩阵" class="headerlink" title="7 Hermite矩阵"></a>7 Hermite矩阵</h2><script type="math/tex; mode=display">A^H=A</script><p>反Hermite矩阵:$A^H=-A$</p><p>Hermite矩阵的特征值均为实数，反Hermite矩阵的特征值为0或者纯虚数</p><h2 id="8-列-行满秩矩阵"><a href="#8-列-行满秩矩阵" class="headerlink" title="8 列/行满秩矩阵"></a>8 列/行满秩矩阵</h2><p>对应的$A^+$为:</p><p>列满秩矩阵: </p><p>(1)$A^+ = (A^HA)^{-1}A^H$</p><p>(2)$AA^+ = I_n$</p><p>行满秩矩阵: </p><p>(1)$A^+ = A^H(AA^H)^{-1}$</p><p>(2)$AA^+ = I_m$</p><h2 id="9-A-矩阵"><a href="#9-A-矩阵" class="headerlink" title="9 $A^+$矩阵"></a>9 $A^+$矩阵</h2><p>(1)$(A^+)^+=A$</p><h2 id="10-幂等矩阵"><a href="#10-幂等矩阵" class="headerlink" title="10 幂等矩阵"></a>10 幂等矩阵</h2><script type="math/tex; mode=display">A^2=A</script><script type="math/tex; mode=display">N(A)=R(I-A)</script><h2 id="11-正规矩阵"><a href="#11-正规矩阵" class="headerlink" title="11 正规矩阵"></a>11 正规矩阵</h2><script type="math/tex; mode=display">A^HA=AA^H</script><p>包含酉矩阵，正交矩阵、Hermite矩阵、实对称矩阵、反Hermite矩阵、实反对称矩阵、对角矩阵等</p><h2 id="12-度量矩阵"><a href="#12-度量矩阵" class="headerlink" title="12 度量矩阵"></a>12 度量矩阵</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper-RAFT</title>
      <link href="2021/11/01/paper-RAFT/"/>
      <url>2021/11/01/paper-RAFT/</url>
      
        <content type="html"><![CDATA[<h1 id="RAFT-—-Recurrent-All-Pairs-Field-Transforms-for-Optical-Flow"><a href="#RAFT-—-Recurrent-All-Pairs-Field-Transforms-for-Optical-Flow" class="headerlink" title="RAFT — Recurrent All-Pairs Field Transforms for Optical Flow"></a>RAFT — Recurrent All-Pairs Field Transforms for Optical Flow</h1><p><strong>发表机构与时间</strong> : International Conference on 3D Vision (3DV), 2021 </p><p><strong>第一作者</strong>：Mathias Gehrig Mario Millh¨ausler Daniel Gehrig Davide Scaramuzza<br>Dept. Informatics, Univ. of Zurich and<br>Dept. of Neuroinformatics, Univ. of Zurich and ETH Zurich</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2003.12039.pdf">戳这里</a></p><p><strong>源码地址</strong> ：<a href="https://github.com/uzh-rpg/E-RAFT">暂时无法访问</a></p><p><strong>数据集地址</strong>: <a href="https://dsec.ifi.uzh.ch">数据集</a></p><h2 id="泛读"><a href="#泛读" class="headerlink" title="泛读"></a>泛读</h2><h3 id="导言："><a href="#导言：" class="headerlink" title="导言："></a>导言：</h3><p><strong>问题</strong>：提高事件形式的数据在光流估计任务中的表现</p><p><strong>难点</strong>：</p><p><strong>相关工作</strong>：光流、事件相机领域</p><p><strong>本文工作</strong>：</p><p>1.与之前在事件领域的光流估计网络相比，除了卷积层之外还引入了<strong>相关特征</strong>，使得效果比之前的网络要好(其实就是把RAFT由RGB相机迁移到事件相机领域)。</p><p>2.提出一个新的数据集。</p><p><strong>阅读过程的疑问和感悟</strong></p><h3 id="特色："><a href="#特色：" class="headerlink" title="特色："></a>特色：</h3><p><img src="/2021/11/01/paper-RAFT/arch.png" alt="网络架构"></p><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><p><strong>原理</strong>：<br><img src="/2021/11/01/paper-RAFT/study.png" alt="代码架构"><br><strong>实验</strong>：</p><p><strong>代码</strong>：</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.paperweekly.site/papers/5221">paperweekly</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper-E-RAFT</title>
      <link href="2021/11/01/paper-E-RAFT/"/>
      <url>2021/11/01/paper-E-RAFT/</url>
      
        <content type="html"><![CDATA[<h1 id="E-RAFT"><a href="#E-RAFT" class="headerlink" title="E-RAFT"></a>E-RAFT</h1><p><strong>发表机构与时间</strong> : International Conference on 3D Vision (3DV), 2021 </p><p><strong>第一作者</strong>：Mathias Gehrig Mario Millh¨ausler Daniel Gehrig Davide Scaramuzza<br>Dept. Informatics, Univ. of Zurich and<br>Dept. of Neuroinformatics, Univ. of Zurich and ETH Zurich</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/pdf/2003.12039.pdf">戳这里</a></p><p><strong>源码地址</strong> ：<a href="https://github.com/uzh-rpg/E-RAFT">暂时无法访问</a></p><p><strong>数据集地址</strong>: <a href="https://dsec.ifi.uzh.ch">数据集</a></p><h2 id="泛读"><a href="#泛读" class="headerlink" title="泛读"></a>泛读</h2><h3 id="导言："><a href="#导言：" class="headerlink" title="导言："></a>导言：</h3><p><strong>问题</strong>：提高事件形式的数据在光流估计任务中的表现</p><p><strong>难点</strong>：</p><p><strong>相关工作</strong>：光流、事件相机领域</p><p><strong>本文工作</strong>：</p><p>1.与之前在事件领域的光流估计网络相比，除了卷积层之外还引入了<strong>相关特征</strong>，使得效果比之前的网络要好(其实就是把RAFT由RGB相机迁移到事件相机领域)。</p><p>2.提出一个新的数据集。</p><p><strong>阅读过程的疑问和感悟</strong></p><h3 id="特色："><a href="#特色：" class="headerlink" title="特色："></a>特色：</h3><p><strong>好像没啥特色</strong>，架构基本就是直接搬的RAFT，就是输入由RGB图像换为了事件图像(事件数据的一种集合表现形式)</p><p><img src="/2021/11/01/paper-E-RAFT/arch.png" alt="网络架构"></p><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><p><strong>原理</strong>：</p><p><strong>实验</strong>：</p><p><strong>代码</strong>：</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.paperweekly.site/papers/5221">paperweekly</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper-Learning optical flow from still images</title>
      <link href="2021/09/15/paper-Learning-optical-flow-from-still-images/"/>
      <url>2021/09/15/paper-Learning-optical-flow-from-still-images/</url>
      
        <content type="html"><![CDATA[<h1 id="Learning-optical-flow-from-still-images"><a href="#Learning-optical-flow-from-still-images" class="headerlink" title="Learning optical flow from still images"></a>Learning optical flow from still images</h1><p><strong>发表机构与时间</strong> : CVPR 2021 </p><p><strong>第一作者</strong>：Filippo Aleotti, Department of Computer Science and Engineering (DISI)<br>University of Bologna, Italy</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/abs/2104.03965">戳这里</a></p><p><strong>源码地址</strong> ：无</p><h2 id="泛读"><a href="#泛读" class="headerlink" title="泛读"></a>泛读</h2><h3 id="导言："><a href="#导言：" class="headerlink" title="导言："></a>导言：</h3><p><strong>问题</strong>：解决光流估计领域中真实图像的光流标签难以获取的问题</p><p><strong>难点</strong>：</p><p><strong>相关工作</strong>：光流领域</p><p><strong>本文工作</strong>：</p><p>作者提出可以通过单张静态图像，利用现成的单目深度估计模型得到深度图，再通过已知的目标旋转和平移变换，就能同时得到视角变换后的新图像，以及对应的光流真值，作者称之为Depthstillation。在此过程中需要解决两个问题，一是冲突像素点，即变换后多个像素点对应同一个像素点，作者提出利用实例分割算法将静态图像中的动态目标检测出来，对这些目标进行运动变换；二是孔洞问题，即变换后存在较多没有对应点的黑色像素点。作者提出利用图像修补（inpaint）的方法对孔洞点进行填充。作者利用FlyingChairs，FlyingThings3D，COCO和DAVIS构建真实光流估计数据集，所提方法在Sintel和KITTI数据集上的实验表明在这些真实图像上利用构造的光流标签训练的性能比利用合成图像和无标签的视频流都要好。</p><p><strong>阅读过程的疑问和感悟</strong></p><h3 id="特色："><a href="#特色：" class="headerlink" title="特色："></a>特色：</h3><p><img src="/2021/09/15/paper-Learning-optical-flow-from-still-images/arch.png" alt="网络架构"></p><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><p><strong>原理</strong>：</p><p><strong>实验</strong>：</p><p><strong>代码</strong>：</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.paperweekly.site/papers/5221">paperweekly</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper-Learning by Distillation -- A Self-Supervised Learning Framework for Optical Flow Estimation</title>
      <link href="2021/09/14/paper-Learning-by-Distillation-A-Self-Supervised-Learning-Framework-for-Optical-Flow-Estimation/"/>
      <url>2021/09/14/paper-Learning-by-Distillation-A-Self-Supervised-Learning-Framework-for-Optical-Flow-Estimation/</url>
      
        <content type="html"><![CDATA[<h1 id="Learning-by-Distillation-A-Self-Supervised-Learning-Framework-for-Optical-Flow-Estimation"><a href="#Learning-by-Distillation-A-Self-Supervised-Learning-Framework-for-Optical-Flow-Estimation" class="headerlink" title="Learning by Distillation: A Self-Supervised Learning Framework for Optical Flow Estimation"></a>Learning by Distillation: A Self-Supervised Learning Framework for Optical Flow Estimation</h1><p><strong>发表机构与时间</strong> : TPAMI 2021 </p><p><strong>第一作者</strong>：Pengpeng Liu</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/abs/2106.04195">戳这里</a></p><p><strong>源码地址</strong> ：无</p><h2 id="泛读"><a href="#泛读" class="headerlink" title="泛读"></a>泛读</h2><h3 id="导言："><a href="#导言：" class="headerlink" title="导言："></a>导言：</h3><p><strong>问题</strong>： 一是如何在不依靠大规模合成数据的条件下，仅仅依靠无标签真实数据来进行有监督光流估计的预训练；二是如何利用无标签数据学习带有遮挡挑战的光流估计任务</p><p><strong>难点</strong>：</p><p><strong>相关工作</strong>：光流领域</p><p><strong>本文工作</strong>：</p><p>本文提出利用蒸馏的方法来进行自监督光流估计的学习。其一是两阶段的模型蒸馏，第一个阶段利用多个教师网络进行自监督学习，通过模型集成挑选出教师网络中置信度较高的光流估计结果，以此作为下一阶段对学生网络的标签。这解决了第一个问题，为有监督光流估计提供了更好的预训练学习范式。其二是数据蒸馏，即人工对输入数据创造具有挑战性的变换，包括遮挡变换、几何变换和色彩变换，从数据层面驱动模型学习处理遮挡场景的光流估计能力，从而解决了第二个问题。本文除了在KITTI数据集上取得了SOTA的性能外，还具有来良好的泛化性能，这包括适用于多种网络结构，泛化到立体匹配问题上，以及跨数据集的泛化性能。[1]</p><p><strong>阅读过程的疑问和感悟</strong></p><p>如何保证老师模型输出的光流精度很高？不高的话又怎么指导学生模型？</p><p>这个在sintel中表现不如RAFT，但是在KITTI达到了SOTA</p><p>在此之前不知道“知识蒸馏”，以后拜读一下Hinton的:Distilling the Knowledge in a Neural Network</p><h3 id="特色："><a href="#特色：" class="headerlink" title="特色："></a>特色：</h3><p>具有良好的泛化性能</p><p><img src="/2021/09/14/paper-Learning-by-Distillation-A-Self-Supervised-Learning-Framework-for-Optical-Flow-Estimation/arch.png" alt="网络架构"></p><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><p><strong>原理</strong>：</p><p><strong>实验</strong>：</p><p><strong>代码</strong>：</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.paperweekly.site/papers/5382">paperweekly</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper-Learning Optical Flow from a Few Matches</title>
      <link href="2021/09/13/paper-Learning-Optical-Flow-from-a-Few-Matches/"/>
      <url>2021/09/13/paper-Learning-Optical-Flow-from-a-Few-Matches/</url>
      
        <content type="html"><![CDATA[<h1 id="Learning-Optical-Flow-from-a-Few-Matches"><a href="#Learning-Optical-Flow-from-a-Few-Matches" class="headerlink" title="Learning Optical Flow from a Few Matches"></a>Learning Optical Flow from a Few Matches</h1><p><strong>发表机构与时间</strong> : CVPR 2021 </p><p><strong>第一作者</strong>：Shihao Jiang , Australian National University</p><p><strong>论文地址</strong> ：<a href="https://arxiv.org/abs/2104.02166">戳这里</a></p><p><strong>源码地址</strong> ：<a href="https://github.com/zacjiang/scv">戳这里</a></p><h2 id="泛读"><a href="#泛读" class="headerlink" title="泛读"></a>泛读</h2><h3 id="导言："><a href="#导言：" class="headerlink" title="导言："></a>导言：</h3><p><strong>问题</strong>： RAFT光流网络虽然效果很好，但是计算成本较高，训练和部署条件比较高。</p><p><strong>难点</strong>：稀疏化，数据结构的改进优化</p><p><strong>相关工作</strong>：光流神经网络架构常基于变分法进行优化求解，初期对大位移解决效果良好，小位移计算结果较差；使用方法逐步变化，初期是使用金字塔方法进行计算，然后使用逐步细化(coarse-to-fine)的方法进行优化计算，经过warp操作后的图像与同一尺寸下的图像进行相关性计算，这时强调warp大过correlation，缺陷是小位移光流无法准确计算。后期出现IRR循环迭代的方式计算光流，旨在降低先前各种光流网络参数逐步增加的趋势。在深度学习之前有一种通过马尔科夫场离散优化求解光流的方法，此类方法基于单分辨率图像进行优化求解光流，而且限制解空间的数量。基于上述的两种情况，后续又提出了RAFT,在单分辨率下进行迭代循环计算光流。有文章之前也是寻找出top-k匹配，但是是通过<strong>稀疏卷积</strong>进行稠密张量化。</p><p><strong>本文工作</strong>：主要是对RAFT的4D Crrelation Volume 进行优化改进，提出了top-k sparse correlation volume，(通过计算一个特征图中的每个特征向量在另一个特征图中的k个最接近匹配直接构造的)；并对后续的稀疏数据进行了稠密化的过程提出了新的编码方式。但是对无特征区域或模糊区域匹配成功度较低。</p><h3 id="特色："><a href="#特色：" class="headerlink" title="特色："></a>特色：</h3><p>改进了RAFT的结构冗余情况，使之使用的内存占用和搜索范围进一步优化。</p><p><img src="/2021/09/13/paper-Learning-Optical-Flow-from-a-Few-Matches/res.png" alt="与RAFT结果比对"></p><p><img src="/2021/09/13/paper-Learning-Optical-Flow-from-a-Few-Matches/arch.png" alt="网络架构改进"></p><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><p><strong>原理</strong>：</p><p><strong>实验</strong>：</p><p><strong>代码</strong>：</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://xxx.com">引用文章标题1</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Large-Scale Study on Unsupervised Spatiotemporal Representation Learning</title>
      <link href="2021/09/02/paper-A-Large-Scale-Study-on-Unsupervised-Spatiotemporal-Representation-Learning/"/>
      <url>2021/09/02/paper-A-Large-Scale-Study-on-Unsupervised-Spatiotemporal-Representation-Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Large-Scale-Study-on-Unsupervised-Spatiotemporal-Representation-Learning"><a href="#A-Large-Scale-Study-on-Unsupervised-Spatiotemporal-Representation-Learning" class="headerlink" title="A Large-Scale Study on Unsupervised Spatiotemporal Representation Learning"></a>A Large-Scale Study on Unsupervised Spatiotemporal Representation Learning</h1><h2 id="导言-摘要"><a href="#导言-摘要" class="headerlink" title="导言/摘要"></a>导言/摘要</h2><p>提出一种框架，将神经网络进一步扩展为时空表述学习，在四种情况下扩展效果很好:</p><p>(i)不同的无监督框架，</p><p>(ii)训练前数据集，</p><p>(iii)下游数据集，</p><p>(iv)骨干架构。</p><p><a href="https://github.com/facebookresearch/SlowFast">源代码</a></p><h2 id="该领域待解决问题"><a href="#该领域待解决问题" class="headerlink" title="该领域待解决问题"></a>该领域待解决问题</h2><h2 id="背景简述"><a href="#背景简述" class="headerlink" title="背景简述"></a>背景简述</h2><h2 id="论文提出的问题"><a href="#论文提出的问题" class="headerlink" title="论文提出的问题"></a>论文提出的问题</h2><h2 id="解决问题手段-步骤"><a href="#解决问题手段-步骤" class="headerlink" title="解决问题手段/步骤"></a>解决问题手段/步骤</h2><h2 id="method原理"><a href="#method原理" class="headerlink" title="method原理"></a>method原理</h2><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://xxx.com">引用文章标题1</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix/linux基础教程</title>
      <link href="2021/03/09/unix-linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>2021/03/09/unix-linux%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="unix-linux基础教程"><a href="#unix-linux基础教程" class="headerlink" title="unix/linux基础教程"></a>unix/linux基础教程</h1><p>在学习ros(官方wiki教程)的过程中发现一篇对于linux新手比较友好的入门教程，其内容深度较浅，不过比较好的覆盖了日常使用的情况。</p><p>在此标注，日后进行补充</p><p><a href="http://www.ee.surrey.ac.uk/Teaching/Unix/">链接</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://xxx.com">引用文章标题1</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake指令使用</title>
      <link href="2021/03/01/cmake%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>2021/03/01/cmake%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="cmake指令使用"><a href="#cmake指令使用" class="headerlink" title="cmake指令使用"></a>cmake指令使用</h1><p>参考自<a href="https://blog.csdn.net/sandalphon4869/article/details/100589747">该博客</a></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h2 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h2><h3 id="内部构建"><a href="#内部构建" class="headerlink" title="内部构建"></a>内部构建</h3><h3 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://xxx.com">引用文章标题1</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>相机成像线性模型</title>
      <link href="2021/02/27/%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/02/27/%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="相机成像线性模型"><a href="#相机成像线性模型" class="headerlink" title="相机成像线性模型"></a>相机成像线性模型</h1><p>做项目时用到了有关相机内参和外参矩阵的相关知识，所以需要自己了解一些相关的基础。而涉及到相机内参和外参矩阵的内容，经查询后发现此部分跟<strong>相机标定</strong>有关。</p><p>相机标定的主要步骤就是<strong>构造</strong>一个以图像信息为输入，图像中相关物体轮廓的三维坐标集合的<strong>数学模型</strong>，然后求解该模型的未知参数（内参矩阵,外参矩阵,畸变参数）,最后应用于实际情况。</p><p>这里我们仅讨论相机的线性模型的建立,即针孔模型，不考虑畸变等复杂情况。</p><h2 id="坐标系简介"><a href="#坐标系简介" class="headerlink" title="坐标系简介"></a>坐标系简介</h2><p>为了更清楚的描述模型的建立的过程，这里通常会以下面四个坐标系为基础进行建模。</p><h3 id="二维图像坐标系"><a href="#二维图像坐标系" class="headerlink" title="二维图像坐标系"></a>二维图像坐标系</h3><p>二维图像坐标系其实也就是以数字图像为基础构造的坐标系，如最常见的二维数组结构组织形式。这里设定列的增长方向为u轴,行的增长方向为v轴。所以$(u,v)$表示数字图像上的某一点的像素坐标。($u,v$通常为非负整数)</p><h3 id="二维成像平面坐标系"><a href="#二维成像平面坐标系" class="headerlink" title="二维成像平面坐标系"></a>二维成像平面坐标系</h3><p>表示图像物理位置的坐标系，在<strong>图像坐标系</strong>的基础上乘以<strong>每像素的物理尺寸</strong>，然后再<strong>加上</strong>原点的偏移量即可。其坐标系坐标点表示为$(x,y)$</p><p><img src="/2021/02/27/%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/uv2xy.png" alt="图像坐标系与成像平面坐标系"></p><p>图像坐标系与成像平面坐标系之间的转换关系如下所示:</p><script type="math/tex; mode=display">\left[\begin{array}{l}u \\ v \\ 1\end{array}\right]=\left[\begin{array}{ccc}1 / d x & 0 & u_{0} \\ 0 & 1 / d y & v_{0} \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]</script><p>其中$u_0,v_0$表示原点分别在列方向，行方向的偏移量。如果按上面图片中的理想状态，则满足$u_0=\frac{w}{2},v_0=\frac{h}{2}$。其中$w,h$为图像的宽，高。</p><p>$d_x,d_y$分别为x,y方向上每像素的物理尺寸。</p><h3 id="三维相机坐标系"><a href="#三维相机坐标系" class="headerlink" title="三维相机坐标系"></a>三维相机坐标系</h3><p>其坐标系中的点表示为$(x_c,y_c,z_c)$,其中深度$Z_c$为相机原点距世界坐标系下实物原点的距离。</p><p>成像平面坐标系与相机坐标系之间的转换关系推导:</p><p><img src="/2021/02/27/%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/xy2xcyc.png" alt="中心透视模型"></p><p>根据上图，我们可以得到如下关系:</p><script type="math/tex; mode=display">\left\{\begin{array}{l}x=f \frac{x_{c}}{z_{c}} \\ y=f \frac{y_{c}}{z_{c}}\end{array}\right.</script><p>可以得到投影矩阵(即成像平面与相机坐标系之间的坐标的关系):</p><script type="math/tex; mode=display">z_{c}\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]=\left[\begin{array}{lll}f & 0 & 0  \\ 0 & f & 0  \\ 0 & 0 & 1 \end{array}\right]\left[\begin{array}{c}x_{c} \\ y_{c} \\ z_{c} \end{array}\right]</script><h3 id="三维世界坐标系"><a href="#三维世界坐标系" class="headerlink" title="三维世界坐标系"></a>三维世界坐标系</h3><p>用来描述物体和物体(相机)之间的相对位置关系。定义其坐标系为$(O-X_WY_WZ_W)$,其坐标系下的坐标点为$(x_w,y_w,z_w)$</p><p>世界坐标系与相机坐标系之间的坐标的关系如下所示:</p><script type="math/tex; mode=display">\left[\begin{array}{c}X_{C} \\ Y_{C} \\ Z_{C} \\ 1\end{array}\right]=\left[\begin{array}{cc}R & t \\ 0^{T} & 1\end{array}\right]\left[\begin{array}{c}X_{W} \\ Y_{W} \\ Z_{W} \\ 1\end{array}\right]</script><p>其中$\left[\begin{array}{cc}R &amp; t \ 0^{T} &amp; 1\end{array}\right]$可以简单表示为$M$(外参矩阵),$t=(t_1,t_2,t_3)^T是平移矩阵$，$R$是$3\times 3$的正交单位矩阵。</p><h2 id="图像坐标系于世界坐标系之间的转换关系"><a href="#图像坐标系于世界坐标系之间的转换关系" class="headerlink" title="图像坐标系于世界坐标系之间的转换关系"></a>图像坐标系于世界坐标系之间的转换关系</h2><p>根据上面各个坐标系之间的转换，我们可以得到图像坐标系与世界坐标系之间的转换关系。</p><script type="math/tex; mode=display">\begin{aligned}\left[\begin{array}{l}u \\ v \\ 1\end{array}\right] &= \left[\begin{array}{ccc}1 / d x & 0 & u_{0} \\ 0 & 1 / d y & v_{0} \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{l}x \\ y \\ 1\end{array}\right]\\ &= \frac{1}{z_{c}} \left[\begin{array}{ccc}1 / d x & 0 & u_{0} \\ 0 & 1 / d y & v_{0} \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{lll}f & 0 & 0  \\ 0 & f & 0  \\ 0 & 0 & 1 \end{array}\right]\left[\begin{array}{c}x_{c} \\ y_{c} \\ z_{c} \end{array}\right] \\&=\frac{1}{z_{c}} \left[\begin{array}{ccc}1 / d x & 0 & u_{0} \\ 0 & 1 / d y & v_{0} \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{lll}f & 0 & 0  \\ 0 & f & 0  \\ 0 & 0 & 1 \end{array}\right]\left[\begin{array}{cc}R & t \end{array}\right]\left[\begin{array}{c}x_{w} \\ y_{w} \\ z_{w}\end{array}\right]\\&=\frac{1}{z_{c}} \left[\begin{array}{ccc}f / d x & 0 & u_{0} \\ 0 & f_ / d y & v_{0} \\ 0 & 0 & 1\end{array}\right]\left[\begin{array}{cc}R & t \end{array}\right]\left[\begin{array}{c}x_{w} \\ y_{w} \\ z_{w}\end{array}\right]\\&=\frac{1}{z_{c}} A M\left[\begin{array}{c}x_{w} \\ y_{w} \\ z_{w}\end{array}\right]\end{aligned}</script><p>其中A为相机内参矩阵，M称为相机外参矩阵</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201402&amp;filename=1014176311.nh&amp;v=W%25mmd2BWq5rRdbITnF4LKzt9zgRxMsjcq8kv77W2Zjx0aUFvIRheJgze92kGfGIcskSkF">舒娜. 摄像机标定方法的研究[D].南京理工大学,2014.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb用法简介</title>
      <link href="2021/02/16/gdb%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>2021/02/16/gdb%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="gdb用法简介"><a href="#gdb用法简介" class="headerlink" title="gdb用法简介"></a>gdb用法简介</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li>进入gdb:  <pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">gdb test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>  test是编译好后生成的可执行文件，不是文件源码。</li><li></li></ul><p>这个其实进入到gdb里面输入<strong>help</strong>就会有相应的命令简介:<br><pre class="line-numbers language-none"><code class="language-none">aliases -- Aliases of other commandsbreakpoints -- Making program stop at certain pointsdata -- Examining datafiles -- Specifying and examining filesinternals -- Maintenance commandsobscure -- Obscure featuresrunning -- Running the programstack -- Examining the stackstatus -- Status inquiriessupport -- Support facilitiestracepoints -- Tracing of program execution without stopping the programuser-defined -- User-defined commands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/euphie/p/9781482.html">gdb基本用法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> debug </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+bat实现由单个pdf生成多个pdf并合并</title>
      <link href="2021/02/15/python+bat%E5%AE%9E%E7%8E%B0%E7%94%B1%E5%8D%95%E4%B8%AApdf%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AApdf%E5%B9%B6%E5%90%88%E5%B9%B6/"/>
      <url>2021/02/15/python+bat%E5%AE%9E%E7%8E%B0%E7%94%B1%E5%8D%95%E4%B8%AApdf%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AApdf%E5%B9%B6%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="python-bat实现由单个pdf生成多个pdf并合并"><a href="#python-bat实现由单个pdf生成多个pdf并合并" class="headerlink" title="python+bat实现由单个pdf生成多个pdf并合并"></a>python+bat实现由单个pdf生成多个pdf并合并</h1><h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>为了方便工作以及节省纸张，老爸提出要一张纸上打印多个重复的cad文件的部分区域。为了方便爸妈使用，所以自己利用python和windows批处理脚本来实现由一个pdf文件生成多个pdf文件并最终合并成1个文件。(家里的电脑系统还是xp,所以还得限制Python版本不能过高，这里选择3.3左右的版本)</p><h2 id="PyPDF2模块介绍"><a href="#PyPDF2模块介绍" class="headerlink" title="PyPDF2模块介绍"></a>PyPDF2模块介绍</h2><p><a href="https://blog.csdn.net/nilvya/article/details/103752817">链接</a></p><h2 id="bat-脚本执行python文件"><a href="#bat-脚本执行python文件" class="headerlink" title="bat 脚本执行python文件"></a>bat 脚本执行python文件</h2><p><a href="https://blog.csdn.net/chang995196962/article/details/84578688">bat批处理执行python文件</a></p><h2 id="python源码"><a href="#python源码" class="headerlink" title="python源码"></a>python源码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#待复制合并的源文件与代码处于同一路径下</span><span class="token keyword">import</span> PyPDF2     <span class="token keyword">import</span> argparse<span class="token comment">#参数初始化</span>parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--name'</span><span class="token punctuation">,</span>                        <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span>                        <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"pdf name"</span><span class="token punctuation">,</span>                        default<span class="token operator">=</span><span class="token string">"每周学习报告.pdf"</span><span class="token punctuation">)</span>parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--num'</span><span class="token punctuation">,</span>                        <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">,</span>                        <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"num"</span><span class="token punctuation">,</span>                        default<span class="token operator">=</span><span class="token string">"4"</span><span class="token punctuation">)</span>args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>pdf1File <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span>     <span class="token comment"># 用二进制只读形式打开文件</span>pdf1Reader <span class="token operator">=</span> PyPDF2<span class="token punctuation">.</span>PdfFileReader<span class="token punctuation">(</span>pdf1File<span class="token punctuation">)</span>    <span class="token comment"># 获取内容对象</span>pdfWriter <span class="token operator">=</span> PyPDF2<span class="token punctuation">.</span>PdfFileWriter<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment"># 创建PDF写入对象</span>pageobj <span class="token operator">=</span> pdf1Reader<span class="token punctuation">.</span>getPage<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    pdfWriter<span class="token punctuation">.</span>addPage<span class="token punctuation">(</span>pageobj<span class="token punctuation">)</span>                 <span class="token comment"># addPage写入内容</span>pdfOutputFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.pdf'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span>   <span class="token comment"># 用二进制写入形式创建新的PDF文件</span>pdfWriter<span class="token punctuation">.</span>write<span class="token punctuation">(</span>pdfOutputFile<span class="token punctuation">)</span>              <span class="token comment"># 将pdfWriter中的内容写入新的PDF文件</span>pdfOutputFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>pdf1File<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/nilvya/article/details/103752817">【Python军火库】PyPDF2：操纵PDF的利器</a><br>[2] <a href="https://blog.csdn.net/chang995196962/article/details/84578688">bat批处理执行python 的几种方式 ———— 批处理， python打包成 exe文件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PyPDF2 </tag>
            
            <tag> doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地机与服务器之间远程传输文件</title>
      <link href="2021/02/15/%E6%9C%AC%E5%9C%B0%E6%9C%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"/>
      <url>2021/02/15/%E6%9C%AC%E5%9C%B0%E6%9C%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="本地机与服务器之间远程传输文件"><a href="#本地机与服务器之间远程传输文件" class="headerlink" title="本地机与服务器之间远程传输文件"></a>本地机与服务器之间远程传输文件</h1><h2 id="本地机-rightarrow-服务器"><a href="#本地机-rightarrow-服务器" class="headerlink" title="本地机$\rightarrow$服务器"></a>本地机$\rightarrow$服务器</h2><p>上传文件命令:<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> file_path_1 root@192.168.1.1:file_path_2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>参数说明:</p><ul><li><strong>file_path_1</strong>: 本地机文件的路径(相对，绝对都可)</li><li><strong>root</strong>:服务器要登录的用户名</li><li><strong>192.168.1.1</strong>:服务器ip地址</li><li><strong>file_path_2</strong>: 上传到服务器上的路径</li></ul><p><strong>注意：</strong> 冒号后面的文件路径与”:”紧连 </p><p>上传目录(整个文件夹)命令:<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span>  -r file_path_1 root@192.168.1.1:file_path_2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="服务器-leftarrow-本地机"><a href="#服务器-leftarrow-本地机" class="headerlink" title="服务器$\leftarrow$本地机"></a>服务器$\leftarrow$本地机</h2><p>下载文件命令:<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> root@192.168.1.1:file_path_2 file_path_1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>参数说明:</p><ul><li><strong>root</strong>:服务器要登录的用户名</li><li><strong>192.168.1.1</strong>:服务器ip地址</li><li><strong>file_path_2</strong>: 服务器上文件的路径</li><li><strong>file_path_1</strong>: 下载到本地机时文件的路径(相对，绝对都可)</li></ul><p>同样加上 <strong>-r</strong> 参数也可以下载目录</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/eline2018/p/10369893.html">Linux 服务器之间文件传输</a></p><p>[2] <a href="https://xxx.com">引用文章标题2</a></p><p>[3] <a href="https://xxx.com">引用文章标题3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于OpenCV函数API文档部分说明的理解</title>
      <link href="2021/02/13/%E5%85%B3%E4%BA%8EOpenCV%E5%87%BD%E6%95%B0API%E6%96%87%E6%A1%A3%E9%83%A8%E5%88%86%E8%AF%B4%E6%98%8E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>2021/02/13/%E5%85%B3%E4%BA%8EOpenCV%E5%87%BD%E6%95%B0API%E6%96%87%E6%A1%A3%E9%83%A8%E5%88%86%E8%AF%B4%E6%98%8E%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="关于OpenCV函数API文档部分说明的理解"><a href="#关于OpenCV函数API文档部分说明的理解" class="headerlink" title="关于OpenCV函数API文档部分说明的理解"></a>关于OpenCV函数API文档部分说明的理解</h1><h2 id="opencv文档中函数头的含义"><a href="#opencv文档中函数头的含义" class="headerlink" title="opencv文档中函数头的含义"></a>opencv文档中函数头的含义</h2><p>之前一直不懂<a href="https://docs.opencv.org/3.0-beta/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#cv2.threshold">opencv函数API文档</a>中python函数头中”[]”的含义， <a href="https://www.zhihu.com/question/307090054">搜索</a>之后结合自己的思考最终理解其含义。</p><p>根据网页上的函数讲解，与c++的函数头对应即可理解:”[]”内的形参表示的是<strong>函数的输出</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://docs.opencv.org/3.0-beta/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#cv2.threshold">opencv函数API文档</a></p><p>[2] <a href="https://www.zhihu.com/question/307090054">搜索</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo载入本地图片</title>
      <link href="2021/02/13/hexo%E8%BD%BD%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
      <url>2021/02/13/hexo%E8%BD%BD%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo载入本地图片"><a href="#hexo载入本地图片" class="headerlink" title="hexo载入本地图片"></a>hexo载入本地图片</h1><h2 id="解决本地图片引用问题"><a href="#解决本地图片引用问题" class="headerlink" title="解决本地图片引用问题"></a>解决本地图片引用问题</h2><p>首先是查到了<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">csdn博客</a>的解决方式，然后觉得对方的过于麻烦，毕竟我安装之后并没有像该作者所说的Bug,所以我直接找到了其对应的github网址。</p><p>按照<a href="https://github.com/xcodebuild/hexo-asset-image">github链接</a>中的说明，新建与文档名相同的文件夹，里面放上对应的图片，然后语法就直接引用图片名称即可，无需路径。(之后新建md文档时会自动生成同名文件夹，不用自己再新建)</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://github.com/xcodebuild/hexo-asset-image">github链接</a></p><p>[1] <a href="https://blog.csdn.net/xjm850552586/article/details/84101345">csdn博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mermaid插件配置</title>
      <link href="2021/02/13/mermaid%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>2021/02/13/mermaid%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="mermaid模块配置"><a href="#mermaid模块配置" class="headerlink" title="mermaid模块配置"></a>mermaid模块配置</h1><h2 id="mermaid插件"><a href="#mermaid插件" class="headerlink" title="mermaid插件"></a>mermaid插件</h2><p>mermaid是markdown编辑器扩展的，方便绘制流程图的语法。</p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>参考自<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">官网</a>,因为<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">模版</a>没有自带mermaid插件扩展，所以需要自己配置，而且也与官网教程有所区别，下面是我自己的配置过程:</p><p>(我使用的是<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">matery</a>模版)</p><ul><li>Step1  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-filter-mermaid-diagrams<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Step2</p><p> 在自己对应<strong>模版</strong>文件夹下的_config.yml中加入以下代码:</p> <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># mermaid chartmermaid: ## mermaid url https:&#x2F;&#x2F;github.com&#x2F;knsv&#x2F;mermaid  enable: true  # default true  version: &quot;7.1.2&quot; # default v7.1.2  options:  # find more api options from https:&#x2F;&#x2F;github.com&#x2F;knsv&#x2F;mermaid&#x2F;blob&#x2F;master&#x2F;src&#x2F;mermaidAPI.js    #startOnload: true  &#x2F;&#x2F; default true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Step3</p><p>模版里面只有<strong>footer.ejs</strong>,所以这里直接在自己模版的<strong>footer.ejs</strong>里面添加官网教程中需要往<strong>after-footer.ejs</strong>文件中添加的内容即可</p><p>添加位置如下:(插个图)</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> mermaid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv基础学习(一)</title>
      <link href="2021/02/13/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>2021/02/13/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV基础学习"><a href="#OpenCV基础学习" class="headerlink" title="OpenCV基础学习"></a>OpenCV基础学习</h1><p>学习的是4.2.0版本的OpenCV,在这里只进行C++和python部分代码的实践。</p><p><a href="https://docs.opencv.org/4.2.0/d9/df8/tutorial_root.html">学习链接</a></p><p>没有标识(C++)表示该部分内容有C++和python两种语言实现。</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="安装opencv环境-C"><a href="#安装opencv环境-C" class="headerlink" title="安装opencv环境(C++)"></a>安装opencv环境(C++)</h3><p>原本想着用docker中的opencv image,只不过没办法显示图像，只能单纯的运行无输出程序。所以无奈只能本地安装opencv</p><p>一开始借鉴<a href="https://zhuanlan.zhihu.com/p/118222087">知乎链接</a>，后来发现按照<a href="https://docs.opencv.org/4.2.0/d7/d9f/tutorial_linux_install.html">官网教程</a>即可把opencv安装好且不需要额外下载内容(教程里一开始的依赖我都下载了)</p><p><strong>注意:</strong> 在安装4.2.0之前貌似服务器上就已经装了opencv3.2.0的版本，在编译好之后才发现这个事情。后来发现opencv4X版本与opencv3x版本配置路径时有所不同，所以应该也是不影响的</p><p><strong>主机系统:ubuntu18.04</strong></p><h4 id="1安装依赖"><a href="#1安装依赖" class="headerlink" title="1安装依赖"></a>1安装依赖</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cmake <span class="token function">git</span> libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2获取源码"><a href="#2获取源码" class="headerlink" title="2获取源码"></a>2获取源码</h4><p>这个知乎教程和官网里面都有，我就不贴了</p><h4 id="3编译opencv"><a href="#3编译opencv" class="headerlink" title="3编译opencv"></a>3编译opencv</h4><p>首先把opencv_contrib和opencv文件夹解压，然后把opencv_contrib复制到opencv文件夹下。<br>然后再在opencv文件夹下新建build文件夹，然后切换到build文件夹下<br>运行以下命令:<br><pre class="line-numbers language-none"><code class="language-none">cmake -D CMAKE_BUILD_TYPE&#x3D;Release -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local .. OPENCV_GENERATE_PKGCONFIG&#x3D;ON<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>没有效果的话就运行下面这条:<br><pre class="line-numbers language-none"><code class="language-none">cmake -DCMAKE_BUILD_TYPE&#x3D;Release -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local .. OPENCV_GENERATE_PKGCONFIG&#x3D;ON<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>然后继续在build目录下运行:<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> -j7 <span class="token comment">#数字可以根据自己的电脑性能适度调整</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>至此opencv安装完毕，下面配置路径</p><h4 id="4配置路径"><a href="#4配置路径" class="headerlink" title="4配置路径"></a>4配置路径</h4><p>先在/etc/ld.so.conf.d/文件夹下新建一个opencv4.conf，里面写入/usr/local/lib。<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/ld.so.conf.d/<span class="token function">sudo</span> <span class="token function">touch</span> opencv4.conf<span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">'echo "/usr/local/lib" > opencv4.conf'</span><span class="token comment">#更新pkg-config</span><span class="token function">sudo</span> ldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>然后运行以下命令检测是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg-config --modversion opencv4 <span class="token comment">#其他版本没有尾后数字  </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/13/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/version_show.png" alt="安装成功"></p><p>运行<a href="https://blog.csdn.net/weixin_44741023/article/details/89604104">测试</a>实例然后就成功了<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#原路径在build文件夹时</span>$ <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/samples/cpp/example_cmake$ cmake <span class="token builtin class-name">.</span>$ <span class="token function">make</span>$ ./opencv_example<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="/2021/02/13/opencv%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%80)/install.png" alt="测试结果"></p><h3 id="安装opencv环境-Python"><a href="#安装opencv环境-Python" class="headerlink" title="安装opencv环境(Python)"></a>安装opencv环境(Python)</h3><p>这个比较简单，在anaconda环境下随便创建个虚拟环境，然后运行下面指令就可以了(其实前面安装好之后本地python也就可以调用cv2，只不过为了本地环境的安全，再新创一个虚拟环境进行python版本的安装)<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install opencv<span class="token operator">-</span>python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="一、简单入门"><a href="#一、简单入门" class="headerlink" title="一、简单入门"></a>一、简单入门</h2><h3 id="使用gcc和cMake编译opencv代码-C"><a href="#使用gcc和cMake编译opencv代码-C" class="headerlink" title="使用gcc和cMake编译opencv代码(C++)"></a>使用gcc和cMake编译opencv代码(C++)</h3><p>在对着<a href="https://docs.opencv.org/4.2.0/db/df5/tutorial_linux_gcc_cmake.html">教程</a>把相关代码配置好后，前面都很顺利，在<strong>make</strong>时却发生了意外报错。</p><p>由于报错信息太多，一开始有点不知道从何下手，所以在折腾了半天之后在网上搜寻能够保存make报错日志的相关<a href="https://www.zhihu.com/question/32236925">命令</a>:<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token operator">></span>make.log<span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>参数解释：</p><ul><li>2: stderr</li><li>1: stdout</li><li>make.log:要生成的日志文件</li></ul><p>大致意思就是把make报错的信息传输到生成的<strong>make.log</strong>文件中。</p><p>然后秉承着<strong>先解决最先报的错</strong>的原则，我们先解决第一个错误:<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">error: &quot;OpenCV&quot; 4.x+ requires enabled c++11 support<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>然后根据网上的<a href="https://blog.csdn.net/qq_38096703/article/details/106001663">相关解答</a>，我在<strong>CMakeList.txt</strong>文件中首行添加了一行代码，修改后的CmakeList.txt文件内容如下所示:<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">set( CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -fPIC -O3 -std&#x3D;c++11 -fopenmp&quot;)cmake_minimum_required(VERSION 2.8)project( DisplayImage )find_package( OpenCV REQUIRED )include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )add_executable( DisplayImage DisplayImage.cpp )target_link_libraries( DisplayImage $&#123;OpenCV_LIBS&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>再次执行cmake,然后执行make,终于编译成功.最后经测试成功显示图像。</p><p>源码解读:<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;int main(int argc, char** argv )&#123;    if ( argc !&#x3D; 2 ) &#x2F;&#x2F;??    &#123;        printf(&quot;usage: DisplayImage.out &lt;Image_Path&gt;\n&quot;);        return -1;    &#125;    Mat image;    image &#x3D; imread( argv[1], 1 ); &#x2F;&#x2F;????    if ( !image.data ) &#x2F;&#x2F;如果为空？    &#123;        printf(&quot;No image data \n&quot;);        return -1;    &#125;    namedWindow(&quot;Display Image&quot;, WINDOW_AUTOSIZE );    imshow(&quot;Display Image&quot;, image);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="显示图像-C"><a href="#显示图像-C" class="headerlink" title="显示图像(C++)"></a>显示图像(C++)</h3><p>源码:<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;opencv2&#x2F;core.hpp&gt; &#x2F;&#x2F;核心，基本操作库#include &lt;opencv2&#x2F;imgcodecs.hpp&gt;#include &lt;opencv2&#x2F;highgui.hpp&gt; &#x2F;&#x2F;包含输入输出的功能#include &lt;iostream&gt;using namespace cv;using namespace std;int main( int argc, char** argv )&#123;    String imageName( &quot;HappyFish.jpg&quot; ); &#x2F;&#x2F; 默认图片    if( argc &gt; 1) &#x2F;&#x2F;如果输入图片名称    &#123;        imageName &#x3D; argv[1]; &#x2F;&#x2F;替换掉默认图片    &#125;    Mat image; &#x2F;&#x2F;存储图像的对象    image &#x3D; imread( samples::findFile( imageName ), IMREAD_COLOR ); &#x2F;&#x2F; 读取文件，IMREAD_COLOR&gt;0(RGB),IMREAD_CGRAYSCALE&#x3D;0(GRAY),IMREAD_UNCHANGED&lt;0(原图)    if( image.empty() )   &#x2F;&#x2F;检查非法输入    &#123;        cout &lt;&lt;  &quot;Could not open or find the image&quot; &lt;&lt; std::endl ;        return -1;    &#125;    namedWindow( &quot;Display window&quot;, WINDOW_AUTOSIZE ); &#x2F;&#x2F; 创建窗口    imshow( &quot;Display window&quot;, image );&#x2F;&#x2F;显示图片    waitKey(0); &#x2F;&#x2F; 等待窗口关闭    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>其他和文件和上一节的一致</p><h3 id="修改和保存图像-C"><a href="#修改和保存图像-C" class="headerlink" title="修改和保存图像(C++)"></a>修改和保存图像(C++)</h3><p>主要就是学习<strong>cv::imread</strong>,<strong>cv::imwrite</strong>,<strong>cv::cvrColor</strong>这三个函数，和python里面的函数功能一致。分别是读取文件，保存文件，转换颜色空间。</p><p>源码<br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;int main( int argc, char** argv )&#123; char* imageName &#x3D; argv[1]; Mat image; image &#x3D; imread( imageName, IMREAD_COLOR ); if( argc !&#x3D; 2 || !image.data ) &#123;   printf( &quot; No image data \n &quot; );   return -1; &#125; Mat gray_image; cvtColor( image, gray_image, COLOR_BGR2GRAY ); imwrite( &quot;..&#x2F;..&#x2F;images&#x2F;Gray_Image.jpg&quot;, gray_image ); namedWindow( imageName, WINDOW_AUTOSIZE ); namedWindow( &quot;Gray image&quot;, WINDOW_AUTOSIZE ); imshow( imageName, image ); imshow( &quot;Gray image&quot;, gray_image ); waitKey(0); return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="二、核心功能"><a href="#二、核心功能" class="headerlink" title="二、核心功能"></a>二、核心功能</h2><p>学习基本构造功能，以及如何在像素级别上操作图像</p><h3 id="Mat-基本图像容器-C"><a href="#Mat-基本图像容器-C" class="headerlink" title="Mat-基本图像容器(C++)"></a>Mat-基本图像容器(C++)</h3><p>学习如何将图像存储在内存中以及如何将其内容打印到控制台</p><h4 id="Mat介绍"><a href="#Mat介绍" class="headerlink" title="Mat介绍"></a>Mat介绍</h4><p>需要了解Mat的第一件事是，不需要手动分配其内存并在不需要时立即释放它。</p><p>Mat本质上是具有两个数据部分的类：矩阵头（包含诸如矩阵大小，存储方法，存储矩阵的地址等信息）以及指向包含该矩阵的矩阵的指针像素值（根据选择的存储方法采用任何尺寸）</p><p>我们要做的最后一件事是通过不必要地复制可能较大的图像来进一步降低程序速度。</p><p>复制运算符只会将标题和指针复制到大型矩阵，而不是数据本身</p><h4 id="存放方法-颜色空间"><a href="#存放方法-颜色空间" class="headerlink" title="存放方法(颜色空间)"></a>存放方法(颜色空间)</h4><ul><li>RGB(A)</li><li>HSV 和 HLS :描述颜色的更自然的方式</li><li>YCrCb</li><li>CIE L <em> a </em> b：通常用于测量给定颜色与另一种颜色的距离<h4 id="创建Mat对象"><a href="#创建Mat对象" class="headerlink" title="创建Mat对象"></a>创建Mat对象</h4></li></ul><p>类型指定约定:<br><pre class="line-numbers language-none"><code class="language-none">CV_[比特位数][有符号或无符号][类型前缀]C[通道数]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h4 id="复制方法-元素复制"><a href="#复制方法-元素复制" class="headerlink" title="复制方法(元素复制)"></a>复制方法(元素复制)</h4><p>这里两个复制函数均是复制之后的变量完全独立，不存在共享数据。</p><p><strong>cv::Mat::clone()</strong></p><p><strong>cv::Mat::copyTo()</strong></p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><h5 id="其他openCV对象的输出"><a href="#其他openCV对象的输出" class="headerlink" title="其他openCV对象的输出"></a>其他openCV对象的输出</h5><p>二维点</p><p>三维点</p><p>vector</p><p>vector of point</p><h3 id="如何使用OpenCV扫描图像，查找表和时间测量-C"><a href="#如何使用OpenCV扫描图像，查找表和时间测量-C" class="headerlink" title="如何使用OpenCV扫描图像，查找表和时间测量(C++)"></a>如何使用OpenCV扫描图像，查找表和时间测量(C++)</h3><p>了解如何使用OpenCV扫描图像（遍历每个图像像素）</p><h3 id="对矩阵进行蒙版运算"><a href="#对矩阵进行蒙版运算" class="headerlink" title="对矩阵进行蒙版运算"></a>对矩阵进行蒙版运算</h3><p>了解如何使用邻居访问来扫描图像，并使用cv :: filter2D函数在图像上应用内核过滤器。</p><p><strong>蒙版运算</strong>其实就是在原始图像上覆膜，或者可以理解为另一类的滤波操作，即提取特定的元素</p><p>所以问题来了，<em>mask矩阵和滤波器核有什么区别呢？</em>—貌似没啥区别</p><p>这里官方的教程个人感觉更偏滤波一些。而且其python的代码风格也有C++非常类似,举的例子也是锐化图像的例子:<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> __future__ <span class="token keyword">import</span> print_function<span class="token keyword">import</span> sys<span class="token keyword">import</span> time<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> cv2 <span class="token keyword">as</span> cv<span class="token keyword">def</span> <span class="token function">is_grayscale</span><span class="token punctuation">(</span>my_image<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#判断是否是灰度图</span>    <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>my_image<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token keyword">def</span> <span class="token function">saturated</span><span class="token punctuation">(</span>sum_value<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#保证计算后的值范围在0-255之间</span>    <span class="token keyword">if</span> sum_value <span class="token operator">></span> <span class="token number">255</span><span class="token punctuation">:</span>        sum_value <span class="token operator">=</span> <span class="token number">255</span>    <span class="token keyword">if</span> sum_value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        sum_value <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> sum_value<span class="token keyword">def</span> <span class="token function">sharpen</span><span class="token punctuation">(</span>my_image<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> is_grayscale<span class="token punctuation">(</span>my_image<span class="token punctuation">)</span><span class="token punctuation">:</span>        height<span class="token punctuation">,</span> width <span class="token operator">=</span> my_image<span class="token punctuation">.</span>shape    <span class="token keyword">else</span><span class="token punctuation">:</span>        my_image <span class="token operator">=</span> cv<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>my_image<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>CV_8U<span class="token punctuation">)</span>        height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> n_channels <span class="token operator">=</span> my_image<span class="token punctuation">.</span>shape    result <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>my_image<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> my_image<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>    <span class="token comment">#滤波操作</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> is_grayscale<span class="token punctuation">(</span>my_image<span class="token punctuation">)</span><span class="token punctuation">:</span>                sum_value <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> my_image<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> \                            <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                result<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> saturated<span class="token punctuation">(</span>sum_value<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n_channels<span class="token punctuation">)</span><span class="token punctuation">:</span>                    sum_value <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> my_image<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">]</span>  \                                <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">]</span>\                                <span class="token operator">-</span> my_image<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">]</span>                    result<span class="token punctuation">[</span>j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> saturated<span class="token punctuation">(</span>sum_value<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">:</span>    filename <span class="token operator">=</span> <span class="token string">'lena.jpg'</span>    img_codec <span class="token operator">=</span> cv<span class="token punctuation">.</span>IMREAD_COLOR    <span class="token keyword">if</span> argv<span class="token punctuation">:</span>        filename <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token keyword">and</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"G"</span><span class="token punctuation">:</span>            img_codec <span class="token operator">=</span> cv<span class="token punctuation">.</span>IMREAD_GRAYSCALE    src <span class="token operator">=</span> cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>cv<span class="token punctuation">.</span>samples<span class="token punctuation">.</span>findFile<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">,</span> img_codec<span class="token punctuation">)</span>    <span class="token keyword">if</span> src <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Can't open image ["</span> <span class="token operator">+</span> filename <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Usage:"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"mat_mask_operations.py [image_path -- default lena.jpg] [G -- grayscale]"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    cv<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">"Input"</span><span class="token punctuation">,</span> cv<span class="token punctuation">.</span>WINDOW_AUTOSIZE<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">"Output"</span><span class="token punctuation">,</span> cv<span class="token punctuation">.</span>WINDOW_AUTOSIZE<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Input"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span>    t <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    dst0 <span class="token operator">=</span> sharpen<span class="token punctuation">(</span>src<span class="token punctuation">)</span>    t <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hand written function time passed in seconds: %s"</span> <span class="token operator">%</span> t<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Output"</span><span class="token punctuation">,</span> dst0<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token punctuation">)</span>    t <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                       <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>  <span class="token comment"># kernel should be floating point type</span>        dst1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>filter2D<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> kernel<span class="token punctuation">)</span>    <span class="token comment"># ddepth = -1, means destination image has depth same as input image</span>        t <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Built-in filter2D time passed in seconds:     %s"</span> <span class="token operator">%</span> t<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Output"</span><span class="token punctuation">,</span> dst1<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>其中的锐化操作可以用 <strong>filter2D()</strong> 来简化，主体内容简化后内容类似下面:<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#import的库与上面的代码相同</span>src <span class="token operator">=</span> cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test.jpg"</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>dst1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>filter2D<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> kernel<span class="token punctuation">)</span><span class="token comment">#input image, depth, kerne(卷积核)</span>cv<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">"Input"</span><span class="token punctuation">,</span> cv<span class="token punctuation">.</span>WINDOW_AUTOSIZE<span class="token punctuation">)</span>cv<span class="token punctuation">.</span>namedWindow<span class="token punctuation">(</span><span class="token string">"Output"</span><span class="token punctuation">,</span> cv<span class="token punctuation">.</span>WINDOW_AUTOSIZE<span class="token punctuation">)</span>cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Input"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span>cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Output"</span><span class="token punctuation">,</span> dst1<span class="token punctuation">)</span>cv<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># ddepth = -1, means destination image has depth same asinput image</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h3><p>从文件读取/写入图像，访问像素，原始操作，可视化图像。</p><h3 id="使用OpenCV添加（混合）两个图像"><a href="#使用OpenCV添加（混合）两个图像" class="headerlink" title="使用OpenCV添加（混合）两个图像"></a>使用OpenCV添加（混合）两个图像</h3><p>将学习如何融合两个图像！</p><h3 id="改变图像的对比度和亮度！"><a href="#改变图像的对比度和亮度！" class="headerlink" title="改变图像的对比度和亮度！"></a>改变图像的对比度和亮度！</h3><p>将学习如何更改图像外观！</p><h3 id="离散傅立叶变换"><a href="#离散傅立叶变换" class="headerlink" title="离散傅立叶变换"></a>离散傅立叶变换</h3><p>了解如何以及为什么在OpenCV中使用离散傅立叶变换</p><h3 id="使用XML和YAML文件的文件输入和输出"><a href="#使用XML和YAML文件的文件输入和输出" class="headerlink" title="使用XML和YAML文件的文件输入和输出"></a>使用XML和YAML文件的文件输入和输出</h3><p>如何使用OpenCV的cv :: FileStorage数据结构将数据写入和读取XML或YAML文件格式</p><h3 id="如何使用OpenCV-parallelfor并行化代码-C"><a href="#如何使用OpenCV-parallelfor并行化代码-C" class="headerlink" title="如何使用OpenCV parallelfor并行化代码(C++)"></a>如何使用OpenCV parallel<em>for</em>并行化代码(C++)</h3><p>如何使用OpenCV parallel<em>for</em>轻松并行化代码。</p><h2 id="三、图像处理"><a href="#三、图像处理" class="headerlink" title="三、图像处理"></a>三、图像处理</h2><p>了解OpenCV内部的图像处理（操作）功能。</p><h3 id="1基本图纸"><a href="#1基本图纸" class="headerlink" title="1基本图纸"></a>1基本图纸</h3><p>学习如何使用OpenCV绘制简单的几何图形</p><h3 id="2带有OpenCV的随机生成器和文本"><a href="#2带有OpenCV的随机生成器和文本" class="headerlink" title="2带有OpenCV的随机生成器和文本"></a>2带有OpenCV的随机生成器和文本</h3><p>使用OpenCV绘制一些精美的东西</p><h3 id="3平滑图像"><a href="#3平滑图像" class="headerlink" title="3平滑图像"></a>3平滑图像</h3><p>一些基本的线性滤波器</p><h3 id="4腐蚀和膨胀"><a href="#4腐蚀和膨胀" class="headerlink" title="4腐蚀和膨胀"></a>4腐蚀和膨胀</h3><p>改变物体的形状</p><h3 id="5更多形态转换"><a href="#5更多形态转换" class="headerlink" title="5更多形态转换"></a>5更多形态转换</h3><p>研究不同的形态运算符</p><h3 id="6命中或缺失"><a href="#6命中或缺失" class="headerlink" title="6命中或缺失"></a>6命中或缺失</h3><p>如何使用“命中或缺失”操作在二进制图像中查找图案</p><h3 id="7使用形态学运算提取水平线和垂直线"><a href="#7使用形态学运算提取水平线和垂直线" class="headerlink" title="7使用形态学运算提取水平线和垂直线"></a>7使用形态学运算提取水平线和垂直线</h3><p>如何使用不同的形态运算符来提取水平线和垂直线</p><h3 id="8影像金字塔"><a href="#8影像金字塔" class="headerlink" title="8影像金字塔"></a>8影像金字塔</h3><p>需要更大/或更小的图像怎么办</p><h3 id="9基本阈值操作"><a href="#9基本阈值操作" class="headerlink" title="9基本阈值操作"></a>9基本阈值操作</h3><p>确定保留哪些像素了</p><h3 id="10使用inRange的阈值操作"><a href="#10使用inRange的阈值操作" class="headerlink" title="10使用inRange的阈值操作"></a>10使用inRange的阈值操作</h3><p>使用inRange函数的阈值操作。</p><h3 id="11制作自己的线性滤波器！"><a href="#11制作自己的线性滤波器！" class="headerlink" title="11制作自己的线性滤波器！"></a>11制作自己的线性滤波器！</h3><p>学习使用OpenCV函数设计自己的过滤器</p><h3 id="12为图像添加边框"><a href="#12为图像添加边框" class="headerlink" title="12为图像添加边框"></a>12为图像添加边框</h3><p>学习如何填充图像</p><h3 id="13Sobel衍生物"><a href="#13Sobel衍生物" class="headerlink" title="13Sobel衍生物"></a>13Sobel衍生物</h3><p>学习如何计算渐变并使用它们来检测边缘</p><h3 id="14拉普拉斯算子"><a href="#14拉普拉斯算子" class="headerlink" title="14拉普拉斯算子"></a>14拉普拉斯算子</h3><p>了解Laplace运算符以及如何使用它检测边缘</p><h3 id="15坎尼边缘检测器"><a href="#15坎尼边缘检测器" class="headerlink" title="15坎尼边缘检测器"></a>15坎尼边缘检测器</h3><p>学习检测边缘的复杂方法</p><h3 id="16霍夫线变换"><a href="#16霍夫线变换" class="headerlink" title="16霍夫线变换"></a>16霍夫线变换</h3><p>学习如何检测线</p><h3 id="17霍夫圆变换"><a href="#17霍夫圆变换" class="headerlink" title="17霍夫圆变换"></a>17霍夫圆变换</h3><p>学习如何检测圈子</p><h3 id="18重新映射"><a href="#18重新映射" class="headerlink" title="18重新映射"></a>18重新映射</h3><p>学习如何操纵像素位置</p><h3 id="19仿射变换"><a href="#19仿射变换" class="headerlink" title="19仿射变换"></a>19仿射变换</h3><p>学习如何旋转，平移和缩放图像</p><h3 id="20直方图均衡"><a href="#20直方图均衡" class="headerlink" title="20直方图均衡"></a>20直方图均衡</h3><p>学习如何改善图像的对比度</p><h3 id="21直方图计算"><a href="#21直方图计算" class="headerlink" title="21直方图计算"></a>21直方图计算</h3><p>学习如何创建和生成直方图</p><h3 id="22直方图比较"><a href="#22直方图比较" class="headerlink" title="22直方图比较"></a>22直方图比较</h3><p>学习计算直方图之间的指标</p><h3 id="23背投"><a href="#23背投" class="headerlink" title="23背投"></a>23背投</h3><p>学习如何使用直方图在图像中找到相似的对象</p><h3 id="24模板匹配"><a href="#24模板匹配" class="headerlink" title="24模板匹配"></a>24模板匹配</h3><p>学习如何匹配图像中的模板</p><h3 id="25在图像中寻找轮廓"><a href="#25在图像中寻找轮廓" class="headerlink" title="25在图像中寻找轮廓"></a>25在图像中寻找轮廓</h3><p>学习如何在图像中找到对象的轮廓</p><h3 id="26凸包"><a href="#26凸包" class="headerlink" title="26凸包"></a>26凸包</h3><p>学习如何获取船体轮廓并绘制它们</p><h3 id="27为轮廓创建边界框和圆"><a href="#27为轮廓创建边界框和圆" class="headerlink" title="27为轮廓创建边界框和圆"></a>27为轮廓创建边界框和圆</h3><p>学习如何获取轮廓的边界框和圆</p><h3 id="28创建轮廓的边界旋转框和椭圆"><a href="#28创建轮廓的边界旋转框和椭圆" class="headerlink" title="28创建轮廓的边界旋转框和椭圆"></a>28创建轮廓的边界旋转框和椭圆</h3><p>学习如何获取轮廓的旋转边界框和椭圆</p><h3 id="29影像时刻"><a href="#29影像时刻" class="headerlink" title="29影像时刻"></a>29影像时刻</h3><p>学习计算图像时刻的地方</p><h3 id="30点多边形测试"><a href="#30点多边形测试" class="headerlink" title="30点多边形测试"></a>30点多边形测试</h3><p>学习如何计算从图像到轮廓的距离</p><h3 id="31基于距离变换和分水岭算法的图像分割"><a href="#31基于距离变换和分水岭算法的图像分割" class="headerlink" title="31基于距离变换和分水岭算法的图像分割"></a>31基于距离变换和分水岭算法的图像分割</h3><p>学习使用拉普拉斯滤波，距离变换和分水岭算法对对象进行分割。</p><h3 id="32离焦去模糊滤镜"><a href="#32离焦去模糊滤镜" class="headerlink" title="32离焦去模糊滤镜"></a>32离焦去模糊滤镜</h3><p>学习如何通过维纳滤镜恢复散焦图像。</p><h3 id="33运动去模糊滤波器"><a href="#33运动去模糊滤波器" class="headerlink" title="33运动去模糊滤波器"></a>33运动去模糊滤波器</h3><p>学习如何使用维纳滤镜恢复运动模糊失真的图像。</p><h3 id="34梯度结构张量的各向异性图像分割"><a href="#34梯度结构张量的各向异性图像分割" class="headerlink" title="34梯度结构张量的各向异性图像分割"></a>34梯度结构张量的各向异性图像分割</h3><p>学习如何通过梯度结构张量分割具有单个局部方向的各向异性图像。</p><h3 id="35周期性除噪滤波器"><a href="#35周期性除噪滤波器" class="headerlink" title="35周期性除噪滤波器"></a>35周期性除噪滤波器</h3><p>学习如何消除傅立叶域中的周期性噪声。</p><h2 id="四、高级GUI和媒体"><a href="#四、高级GUI和媒体" class="headerlink" title="四、高级GUI和媒体"></a>四、高级GUI和媒体</h2><p>如何使用库的内置图形用户界面的有价值的教程。</p><h3 id="在程序中添加跟踪栏"><a href="#在程序中添加跟踪栏" class="headerlink" title="在程序中添加跟踪栏"></a>在程序中添加跟踪栏</h3><p>将学习如何在应用程序中添加跟踪栏</p><h2 id="五、图像输入和输出"><a href="#五、图像输入和输出" class="headerlink" title="五、图像输入和输出"></a>五、图像输入和输出</h2><p>如何使用imgcodecs模块读取和写入图像。</p><h3 id="使用GDAL读取地理空间栅格文件"><a href="#使用GDAL读取地理空间栅格文件" class="headerlink" title="使用GDAL读取地理空间栅格文件"></a>使用GDAL读取地理空间栅格文件</h3><p>读取常见的GIS Raster和DEM文件以显示和处理地理数据。</p><h2 id="六、视频输入和输出"><a href="#六、视频输入和输出" class="headerlink" title="六、视频输入和输出"></a>六、视频输入和输出</h2><p>如何使用videio模块读取和写入视频。</p><h3 id="具有OpenCV和相似度测量的视频输入"><a href="#具有OpenCV和相似度测量的视频输入" class="headerlink" title="具有OpenCV和相似度测量的视频输入"></a>具有OpenCV和相似度测量的视频输入</h3><p>学习如何读取视频流，以及如何计算相似度值，例如PSNR或SSIM。</p><h3 id="使用OpenCV创建视频"><a href="#使用OpenCV创建视频" class="headerlink" title="使用OpenCV创建视频"></a>使用OpenCV创建视频</h3><h3 id="使用Kinect和其他OpenNI兼容的深度传感器"><a href="#使用Kinect和其他OpenNI兼容的深度传感器" class="headerlink" title="使用Kinect和其他OpenNI兼容的深度传感器"></a>使用Kinect和其他OpenNI兼容的深度传感器</h3><h3 id="使用Creative-Senz3D和其他兼容Intel-Perceptual-Computing-SDK的深度传感器"><a href="#使用Creative-Senz3D和其他兼容Intel-Perceptual-Computing-SDK的深度传感器" class="headerlink" title="使用Creative Senz3D和其他兼容Intel Perceptual Computing SDK的深度传感器"></a>使用Creative Senz3D和其他兼容Intel Perceptual Computing SDK的深度传感器</h3><h2 id="七、相机校准和3D重建"><a href="#七、相机校准和3D重建" class="headerlink" title="七、相机校准和3D重建"></a>七、相机校准和3D重建</h2><p>如何从2D图像中找出3D世界信息。</p><h3 id="创建校准图案"><a href="#创建校准图案" class="headerlink" title="创建校准图案"></a>创建校准图案</h3><p>学习如何创建一些校准图案。</p><h3 id="用方形棋盘进行相机校准"><a href="#用方形棋盘进行相机校准" class="headerlink" title="用方形棋盘进行相机校准"></a>用方形棋盘进行相机校准</h3><p>使用一些棋盘图像来校准相机。</p><h3 id="使用OpenCV进行相机校准"><a href="#使用OpenCV进行相机校准" class="headerlink" title="使用OpenCV进行相机校准"></a>使用OpenCV进行相机校准</h3><p>通过使用棋盘，圆圈或不对称圆圈图案进行相机校准</p><h3 id="纹理对象的实时姿态估计"><a href="#纹理对象的实时姿态估计" class="headerlink" title="纹理对象的实时姿态估计"></a>纹理对象的实时姿态估计</h3><p>使用ORB功能，基于FlannBased的匹配器，PnP方法以及Ransac和线性卡尔曼滤波器对纹理对象的实时姿态估计，可以拒绝可能的不良姿态。</p><h3 id="交互式相机校准应用"><a href="#交互式相机校准应用" class="headerlink" title="交互式相机校准应用"></a>交互式相机校准应用</h3><p>通过使用棋盘，chAruco，不对称圆圈或双重不对称圆圈图案进行相机校准</p><h2 id="八、2D功能框架"><a href="#八、2D功能框架" class="headerlink" title="八、2D功能框架"></a>八、2D功能框架</h2><p>如何使用OpenCV中的特征点检测器，描述符和匹配框架的信息。</p><h3 id="哈里斯拐角探测器"><a href="#哈里斯拐角探测器" class="headerlink" title="哈里斯拐角探测器"></a>哈里斯拐角探测器</h3><p>为什么跟踪拐角是个好主意？我们将学习如何使用Harris方法来检测角点。</p><h3 id="Shi-Tomasi拐角检测器"><a href="#Shi-Tomasi拐角检测器" class="headerlink" title="Shi-Tomasi拐角检测器"></a>Shi-Tomasi拐角检测器</h3><p>在这里我们使用一种改进的方法来更准确地检测拐角。</p><h3 id="创建自己的角落探测器"><a href="#创建自己的角落探测器" class="headerlink" title="创建自己的角落探测器"></a>创建自己的角落探测器</h3><p>在这里，您将学习如何使用OpenCV功能制作个性化的角检测器！</p><h3 id="检测子像素中的角位置"><a href="#检测子像素中的角位置" class="headerlink" title="检测子像素中的角位置"></a>检测子像素中的角位置</h3><p>像素分辨率够吗？在这里，我们学习了一种提高角点定位精度的简单方法。</p><h3 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h3><p>在本教程中，您将使用features2d检测兴趣点。</p><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><p>在本教程中，您将使用features2d计算特征向量。</p><h3 id="与FLANN的功能匹配"><a href="#与FLANN的功能匹配" class="headerlink" title="与FLANN的功能匹配"></a>与FLANN的功能匹配</h3><p>在本教程中，您将使用FLANN库进行快速匹配。</p><h3 id="2D-全息照相法查找已知物体"><a href="#2D-全息照相法查找已知物体" class="headerlink" title="2D +全息照相法查找已知物体"></a>2D +全息照相法查找已知物体</h3><p>在本教程中，您将使用features2d和calib3d来检测场景中的对象。 </p><h3 id="检测平面物体"><a href="#检测平面物体" class="headerlink" title="检测平面物体"></a>检测平面物体</h3><p>您将使用features2d和calib3d模块来检测场景中已知的平面对象。</p><h3 id="AKAZE本地特征匹配"><a href="#AKAZE本地特征匹配" class="headerlink" title="AKAZE本地特征匹配"></a>AKAZE本地特征匹配</h3><p>使用AKAZE局部特征查找两个图像之间的对应关系。</p><h3 id="AKAZE和ORB平面跟踪"><a href="#AKAZE和ORB平面跟踪" class="headerlink" title="AKAZE和ORB平面跟踪"></a>AKAZE和ORB平面跟踪</h3><p>使用AKAZE和ORB进行平面物体跟踪。</p><h3 id="用代码解释单应性的基本概念"><a href="#用代码解释单应性的基本概念" class="headerlink" title="用代码解释单应性的基本概念"></a>用代码解释单应性的基本概念</h3><p>本教程将通过一些演示代码解释单应性的基本概念。</p><h2 id="九、视频分析"><a href="#九、视频分析" class="headerlink" title="九、视频分析"></a>九、视频分析</h2><p>用于视频流的算法，例如运动提取，特征跟踪和前景提取。</p><h3 id="如何使用背景减法"><a href="#如何使用背景减法" class="headerlink" title="如何使用背景减法"></a>如何使用背景减法</h3><p>我们将学习如何从视频和图像序列中提取前景蒙版并显示它们。</p><h3 id="Meanshift和Camshift"><a href="#Meanshift和Camshift" class="headerlink" title="Meanshift和Camshift"></a>Meanshift和Camshift</h3><p>了解如何使用Meanshift和Camshift算法跟踪视频中的对象。</p><h3 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h3><p>将学习如何使用光流方法来跟踪稀疏特征或创建密集表示。</p><h2 id="十、对象检测"><a href="#十、对象检测" class="headerlink" title="十、对象检测"></a>十、对象检测</h2><p>检测人脸</p><h3 id="级联分类器"><a href="#级联分类器" class="headerlink" title="级联分类器"></a>级联分类器</h3><p>在这里，我们学习如何使用objdetect在我们的图像或视频中查找对象</p><h3 id="级联分类器训练"><a href="#级联分类器训练" class="headerlink" title="级联分类器训练"></a>级联分类器训练</h3><p>本教程描述了opencv_traincascade应用程序及其参数。</p><h2 id="十一、深度神经网络"><a href="#十一、深度神经网络" class="headerlink" title="十一、深度神经网络"></a>十一、深度神经网络</h2><p>展示了如何有效地使用dnn模块。</p><h3 id="加载Caffe框架模型"><a href="#加载Caffe框架模型" class="headerlink" title="加载Caffe框架模型"></a>加载Caffe框架模型</h3><p>在本教程中，您将学习如何使用来自Caffe模型动物园的GoogLeNet训练的网络，将opencv_dnn模块用于图像分类。</p><h3 id="如何启用卤化物后端以提高效率"><a href="#如何启用卤化物后端以提高效率" class="headerlink" title="如何启用卤化物后端以提高效率"></a>如何启用卤化物后端以提高效率</h3><p>本教程指导如何使用Halide语言后端在OpenCV深度学习模块中运行模型。</p><h3 id="如何为您的Halide后端安排网络"><a href="#如何为您的Halide后端安排网络" class="headerlink" title="如何为您的Halide后端安排网络"></a>如何为您的Halide后端安排网络</h3><p>在本教程中，我们描述了使用OpenCV深度学习模块中的Halide后端调度网络的方法。</p><h3 id="如何在Android设备上运行深度网络"><a href="#如何在Android设备上运行深度网络" class="headerlink" title="如何在Android设备上运行深度网络"></a>如何在Android设备上运行深度网络</h3><p>本教程将向您展示如何在Android设备上使用OpenCV运行深度学习模型。</p><h3 id="YOLO-DNN"><a href="#YOLO-DNN" class="headerlink" title="YOLO DNN"></a>YOLO DNN</h3><p>在本教程中，您将学习如何通过yolo_object_detection和设备捕获，视频文件或图像使用opencv_dnn模块。</p><h3 id="如何在浏览器中运行深度网络"><a href="#如何在浏览器中运行深度网络" class="headerlink" title="如何在浏览器中运行深度网络"></a>如何在浏览器中运行深度网络</h3><p>在本教程中，我们将使用OpenCV.js在浏览器中运行深度学习模型。</p><h3 id="自定义深度学习层支持"><a href="#自定义深度学习层支持" class="headerlink" title="自定义深度学习层支持"></a>自定义深度学习层支持</h3><p>如何定义自定义图层以导入网络。</p><h2 id="十二、机器学习"><a href="#十二、机器学习" class="headerlink" title="十二、机器学习"></a>十二、机器学习</h2><p>使用功能强大的机器学习类进行统计分类，数据回归和聚类。</p><h3 id="支持向量机简介"><a href="#支持向量机简介" class="headerlink" title="支持向量机简介"></a>支持向量机简介</h3><p>了解什么是支持向量机。</p><h3 id="支持向量机用于非线性可分离数据"><a href="#支持向量机用于非线性可分离数据" class="headerlink" title="支持向量机用于非线性可分离数据"></a>支持向量机用于非线性可分离数据</h3><p>在这里，您将学习在无法线性分离训练数据时如何定义SVM的优化问题</p><h3 id="主成分分析（PCA）简介"><a href="#主成分分析（PCA）简介" class="headerlink" title="主成分分析（PCA）简介"></a>主成分分析（PCA）简介</h3><p>了解什么是主成分分析（PCA）</p><h2 id="十三、Graph-API"><a href="#十三、Graph-API" class="headerlink" title="十三、Graph API"></a>十三、Graph API</h2><p>了解如何使用图形API（G-API）和从“传统” OpenCV到图形模型的端口算法</p><h2 id="十四、计算摄影"><a href="#十四、计算摄影" class="headerlink" title="十四、计算摄影"></a>十四、计算摄影</h2><p>使用OpenCV进行高级照片处理。</p><h3 id="高动态范围成像"><a href="#高动态范围成像" class="headerlink" title="高动态范围成像"></a>高动态范围成像</h3><p>了解如何创建和处理高动态范围图像。</p><h2 id="十五、图像拼接"><a href="#十五、图像拼接" class="headerlink" title="十五、图像拼接"></a>十五、图像拼接</h2><p>了解如何使用OpenCV缝合管线创建美丽的照片全景图以及其他内容。</p><h3 id="高级拼接API（Stitcher类）"><a href="#高级拼接API（Stitcher类）" class="headerlink" title="高级拼接API（Stitcher类）"></a>高级拼接API（Stitcher类）</h3><p>您将使用高级拼接API创建照片全景。您将了解Stitcher类及其配置。</p><h2 id="十六、GPU加速"><a href="#十六、GPU加速" class="headerlink" title="十六、GPU加速"></a>十六、GPU加速</h2><p>利用视频卡的功能来运行OpenCV算法，从系统中挤出几乎所有的计算能力。</p><h3 id="GPU上的相似性检查（PNSR和SSIM）"><a href="#GPU上的相似性检查（PNSR和SSIM）" class="headerlink" title="GPU上的相似性检查（PNSR和SSIM）"></a>GPU上的相似性检查（PNSR和SSIM）</h3><h3 id="用推力使用cv-cuda-GpuMat"><a href="#用推力使用cv-cuda-GpuMat" class="headerlink" title="用推力使用cv :: cuda :: GpuMat"></a>用推力使用cv :: cuda :: GpuMat</h3><h2 id="十七、Opencv-ios"><a href="#十七、Opencv-ios" class="headerlink" title="十七、Opencv ios"></a>十七、Opencv ios</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://docs.opencv.org/4.2.0/d9/df8/tutorial_root.html">OpenCV学习教程</a></p><p>[2] <a href="https://docs.opencv.org/4.2.0/d9/df8/tutorial_root.html">在linux上正确的姿势安装OpenCV</a></p><p>[3] <a href="https://blog.csdn.net/weixin_44741023/article/details/89604104">ubuntu16.04下载opencv3.4.0并检测是否安装成功</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用selenium+chromedriver爬取数据</title>
      <link href="2021/02/12/%E4%BD%BF%E7%94%A8selenium-chromedriver%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>2021/02/12/%E4%BD%BF%E7%94%A8selenium-chromedriver%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="使用爬虫爬取知网目录"><a href="#使用爬虫爬取知网目录" class="headerlink" title="使用爬虫爬取知网目录"></a>使用爬虫爬取知网目录</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>想要获取知网搜索结果页面中的侧栏中的<strong>学科导航</strong>中的大纲的内容，然后依次来构建知识体系。但是后来发现简单爬取只能爬取部分代码，而导航栏的源代码只有在点击相应学科才能加载出相应代码。所以后面用到了<strong>selenium</strong>神器。<br><img src="/2021/02/12/%E4%BD%BF%E7%94%A8selenium-chromedriver%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/1j65r9.jpg" alt="test"></p><h2 id="使用普通爬虫未遂"><a href="#使用普通爬虫未遂" class="headerlink" title="使用普通爬虫未遂"></a>使用普通爬虫未遂</h2><p><a href="https://zhuanlan.zhihu.com/p/270391233">链接</a></p><h2 id="使用selenium进行爬取"><a href="#使用selenium进行爬取" class="headerlink" title="使用selenium进行爬取"></a>使用selenium进行爬取</h2><p><a href="https://blog.csdn.net/qq_37503890/article/details/99292343">链接</a></p><h3 id="下载google-chrome"><a href="#下载google-chrome" class="headerlink" title="下载google chrome"></a>下载google chrome</h3><p><a href="https://www.google.com/intl/zh-CN/chrome/">链接</a></p><h3 id="下载chromedriver"><a href="#下载chromedriver" class="headerlink" title="下载chromedriver"></a>下载chromedriver</h3><p>选择与浏览器版本相似的也可以，不一定非得必须一致<br><a href="http://chromedriver.storage.googleapis.com/index.html">链接</a></p><h3 id="下载selenium"><a href="#下载selenium" class="headerlink" title="下载selenium"></a>下载selenium</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install selenium<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遇到问题:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Message<span class="token punctuation">:</span> <span class="token string">'chromedriver'</span> executable needs to be <span class="token keyword">in</span> PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_44335092/article/details/109054128">解决方法</a>,<br>我是前几种方法无效，所以用了最后一种绝对路径引用。</p><h3 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""获取网页源代码并且将侧栏文本内容进行整理"""</span><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>keys <span class="token keyword">import</span> Keys<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support <span class="token keyword">import</span> expected_conditions <span class="token keyword">as</span> EC<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>wait <span class="token keyword">import</span> WebDriverWait<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>action_chains <span class="token keyword">import</span> ActionChains<span class="token keyword">import</span> timebrowser<span class="token operator">=</span>webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span>executable_path<span class="token operator">=</span><span class="token string">r'E:\chrome\chromedriver_win32\chromedriver.exe'</span><span class="token punctuation">)</span>f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"./test.txt"</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token comment">#保存源代码的文件</span><span class="token keyword">try</span><span class="token punctuation">:</span>    browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://concept.cnki.net/"</span><span class="token punctuation">)</span> <span class="token comment">#访问知网概念知识库</span>    <span class="token builtin">input</span><span class="token operator">=</span>browser<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"search_box"</span><span class="token punctuation">)</span>  <span class="token comment">#获取搜索栏的id</span>    <span class="token builtin">input</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"slam"</span><span class="token punctuation">)</span>    <span class="token builtin">input</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>ENTER<span class="token punctuation">)</span>    wait<span class="token operator">=</span>WebDriverWait<span class="token punctuation">(</span>browser<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>    wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span><span class="token string">"treeMenu1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">505</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        browser<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"window.scrollTo(0,"</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">)</span> <span class="token comment">#把网页滚动到底(否则后面的点击看不到时会报错)</span>        <span class="token comment">#window.scrollTo(x,y):滑动到x,y位置</span>        button <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"treeMenu1_"</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"_switch"</span><span class="token punctuation">)</span>  <span class="token comment">#获取侧边栏按钮的Id treeMenu1_49_a</span>        name <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"treeMenu1_"</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"_span"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text <span class="token comment">#获取文本字符串</span>        level <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"treeMenu1_"</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"_a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_attribute<span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">)</span>  <span class="token comment">#获取文本对应等级</span>        level <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>level<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span>        ActionChainsDriver <span class="token operator">=</span> ActionChains<span class="token punctuation">(</span>browser<span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span>button<span class="token punctuation">)</span> <span class="token comment">#点击对应按钮</span>        ActionChainsDriver<span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#执行点击动作</span>    <span class="token comment">#f.write(browser.page_source) #保存当前的网页源代码</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    browser<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><center>![爬取结果](res.png)</center><p>如果想进行更深入的学习，可以查看selenium的官方文档:</p><p><a href="https://www.selenium.dev/selenium/docs/api/py/api.html">官方文档</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/youngleesin/p/10449356.html">selenium.模拟鼠标操作（ActionChains</a></p><p>[2] <a href="https://www.cnblogs.com/yuer20180726/p/10789426.html">自动化测试基础篇—Selenium获取元素属性</a></p><p>[3] <a href="https://www.runoob.com/jsref/met-win-scrollto.html">windowscrollTo()用法</a></p><p>[4] <a href="https://blog.csdn.net/weixin_34163741/article/details/93594002">Python 保存数据的方法（4种方法）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test及github上传流程</title>
      <link href="2021/02/10/test/"/>
      <url>2021/02/10/test/</url>
      
        <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>该文档是暂时存放<strong>未解决</strong>问题的记录文档</p><h2 id="未解决-emoji表情测试"><a href="#未解决-emoji表情测试" class="headerlink" title="[未解决]emoji表情测试"></a>[未解决]emoji表情测试</h2><p>:smile:</p><p>:scream:</p><p>:kissing_heart:</p><p>:goat:</p><h2 id="未解决-字体测试"><a href="#未解决-字体测试" class="headerlink" title="[未解决]字体测试"></a>[未解决]字体测试</h2><font face="wxz">莫使金樽空对月</font><p>(本地端口可以显示，但是挂到网上无法显示)</p><p>参考自该<a href="https://blog.csdn.net/huangpb123/article/details/104231496">博客</a>,只需把以下代码写入模版中的<strong>my.css</strong>中即可:<br><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span></span><span class="token punctuation">&#123;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> wxz<span class="token punctuation">;</span>  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"./wxz.ttf"</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="github上传流程-核心版"><a href="#github上传流程-核心版" class="headerlink" title="github上传流程(核心版)"></a>github上传流程(核心版)</h2><p>git add .</p><p>git commit -m “xxx”</p><p>git push </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji表情代码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/02/08/hello-world/"/>
      <url>2021/02/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>创建新文章</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>本地端口测试网页效果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server <span class="token comment"># or hexo s</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p>生成静态网页</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate <span class="token comment"># or hexo g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>上传网页</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy <span class="token comment"># or hexo d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><a href="https://zhuanlan.zhihu.com/p/137476045">使用教程参考博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 hexo d 执行中断</title>
      <link href="2021/02/08/hexo%E9%97%AE%E9%A2%981/"/>
      <url>2021/02/08/hexo%E9%97%AE%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-d-命令只实现部分"><a href="#hexo-d-命令只实现部分" class="headerlink" title="hexo d 命令只实现部分"></a>hexo d 命令只实现部分</h1><h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>在按照相关<a href="https://zhuanlan.zhihu.com/p/35668237">教程</a>搭建博客时,前面的安装以及<strong>hexo g</strong>,<strong>hexo s</strong>顺利完成，但是在执行<strong>hexo d</strong>时出现了意外,在其执行过程中突然中断,并未显示执行完成的标志:<strong>INFO Deploy done: git</strong></p><p>失败结果如下所示:<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo dINFO  Validating configINFO  Deploying: <span class="token function">git</span>INFO  Clearing .deploy_git folder<span class="token punctuation">..</span>.INFO  Copying files from public folder<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>在网上查找了许多教程都没有作用，之后又查询了一番，突然发现stackflow上面的一个<a href="https://stackoverflow.com/questions/66095027/after-hexo-d-when-diaplay-copying-files-from-public-folder-git-stopped-i-do">提问</a>和我遇到的问题一样，但是没有人回答，所以等待了一段时间有人回复之后，发现最终引到了hexo官方github里面的issue中的一个<a href="https://github.com/hexojs/hexo/issues/4634">问题</a>，这才明白可能自己遇到了新出现的bug。</p><p>在这里贴出相关解决代码：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在git bash 里面执行</span><span class="token function">npm</span> un hexo-deployer-git<span class="token comment">#这一句要切换到master分支(.deploy_git/)里面安装</span><span class="token function">npm</span> i hexojs/hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>这也让我明白了如果2小时内找不到任何解决方案的话，最好找到官网及其相关信息查询。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>github新版仓库初始化README时默认是生成main分支而不是master分支，而hexo默认是生成master分支(改了_config.yaml里的branch也没用),所以在生成仓库前把branch默认名的设置更改为master即可。</p><h3 id="配图"><a href="#配图" class="headerlink" title="配图"></a>配图</h3><p>测试：<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pytorch<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npm <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="2021/02/08/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>2021/02/08/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@<a href="这里写自定义目录标题">TOC</a></p><h1 id="Markdown语法入门"><a href="#Markdown语法入门" class="headerlink" title="Markdown语法入门"></a>Markdown语法入门</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<sup><a href="#fn_1" id="reffn_1">1</a></sup></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H~2~O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p><p>带尺寸的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30" alt="Alt"></p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30" alt="Alt"></p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.<br><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// An highlighted block</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li>[ ] 计划任务</li><li>[x] 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>项目     | Value<br>———— | ——-<br>电脑  | $1600<br>手机  | $12<br>导管  | $1</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:—————-:| ——————-:|:——————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|————————|———————————————-|——————————————-|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|— is en-dash, —- is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><p>Markdown<br>:  Text-to-HTML conversion tool</p><p>Authors<br>:  John<br>:  Luke</p><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><blockquote id="fn_2"><sup>2</sup>. 注脚的解释<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><script type="math/tex; mode=display">\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.</script><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><pre class="mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d</pre>- 关于 **甘特图** 语法，参考 [这儿][2],## UML 图表可以使用UML图表进行渲染。 [Mermaid](https://mermaidjs.github.io/). 例如下面产生的一个序列图：<pre class="mermaid">sequenceDiagram张三 ->> 李四: 你好！李四, 最近怎么样?李四-->>王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了<br>不适合放在一行.李四-->>张三: 打量着王五...张三->>王五: 很好... 王五, 你怎么样?</pre><p>这将产生一个流程图。:</p><pre class="mermaid">graph LRA[长方形] -- 链接 --> B((圆))A --> C(圆角长方形)B --> D{菱形}C --> D</pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><pre class="mermaid">flowchatst=>start: 开始e=>end: 结束op=>operation: 我的操作cond=>condition: 确认？st->op->condcond(yes)->econd(no)->op</pre><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p> [1]<a href="https://editor.csdn.net/md/">csdn博客markdown编辑器使用方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
